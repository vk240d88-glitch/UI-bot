import streamlit as st
import pandas as pd
import ccxt
import requests
import time
import json
import logging
import threading
import re
import random
import os
import sys
import gc
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import pandas_ta as ta
from bs4 import BeautifulSoup
import numpy as np

# üîß –£–í–ï–õ–ò–ß–ò–í–ê–ï–ú –õ–ò–ú–ò–¢ –†–ï–ö–£–†–°–ò–ò –î–õ–Ø STREAMLIT
sys.setrecursionlimit(2000)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('trading_bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# üîß –ö–õ–ê–°–° –î–õ–Ø –£–ü–†–ê–í–õ–ï–ù–ò–Ø –°–û–°–¢–û–Ø–ù–ò–ï–ú –ë–ï–ó –†–ï–ö–£–†–°–ò–ò
class BotStateManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —Ä–µ–∫—É—Ä—Å–∏–∏"""
    
    def __init__(self):
        self._state = {}
        self._lock = threading.Lock()
        self._last_cleanup = datetime.now()
    
    def get(self, key, default=None):
        with self._lock:
            return self._state.get(key, default)
    
    def set(self, key, value):
        with self._lock:
            self._state[key] = value
            
            # üîß –ê–í–¢–û–û–ß–ò–°–¢–ö–ê –°–¢–ê–†–´–• –î–ê–ù–ù–´–• –ö–ê–ñ–î–´–ï 2 –ß–ê–°–ê
            if (datetime.now() - self._last_cleanup) > timedelta(hours=2):
                self._cleanup_old_data()
                self._last_cleanup = datetime.now()
    
    def _cleanup_old_data(self):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —É—Ç–µ—á–µ–∫ –ø–∞–º—è—Ç–∏"""
        keys_to_remove = []
        current_time = datetime.now()
        
        for key, value in self._state.items():
            if isinstance(value, dict) and 'timestamp' in value:
                try:
                    value_time = datetime.fromisoformat(value['timestamp'])
                    if (current_time - value_time) > timedelta(hours=6):
                        keys_to_remove.append(key)
                except:
                    keys_to_remove.append(key)
        
        for key in keys_to_remove:
            del self._state[key]
        
        if keys_to_remove:
            logger.info(f"üßπ –û—á–∏—â–µ–Ω–æ {len(keys_to_remove)} —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –∑–∞–ø–∏—Å–µ–π —Å–æ—Å—Ç–æ—è–Ω–∏—è")

# üîß –°–û–ó–î–ê–ï–ú –ì–õ–û–ë–ê–õ–¨–ù–´–ô –ú–ï–ù–ï–î–ñ–ï–† –°–û–°–¢–û–Ø–ù–ò–Ø
state_manager = BotStateManager()

class FreeSocialSentimentAnalyzer:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π —Å NLP –∏ –≤–µ—Å–∞–º–∏"""
    
    def __init__(self):
        self.cache = {}
        self.methods = [
            self.coingecko_sentiment,
            self.lunarcrush_sentiment, 
            self.crypto_news_sentiment,
        ]
        self.weights = [0.4, 0.3, 0.3]
        self._last_cache_cleanup = datetime.now()
    
    def _cleanup_old_cache(self):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –∫—ç—à–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —É—Ç–µ—á–µ–∫ –ø–∞–º—è—Ç–∏"""
        if (datetime.now() - self._last_cache_cleanup) > timedelta(hours=1):
            keys_to_remove = []
            current_time = datetime.now()
            
            for key in list(self.cache.keys()):
                # –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å–∏ —Å—Ç–∞—Ä—à–µ 2 —á–∞—Å–æ–≤
                if '_' in key:
                    try:
                        time_str = key.split('_')[-1]
                        cache_time = datetime.strptime(time_str, '%Y%m%d%H')
                        if (current_time - cache_time) > timedelta(hours=2):
                            keys_to_remove.append(key)
                    except:
                        keys_to_remove.append(key)
            
            for key in keys_to_remove:
                if key in self.cache:
                    del self.cache[key]
            
            if keys_to_remove:
                logger.info(f"üßπ –û—á–∏—â–µ–Ω–æ {len(keys_to_remove)} —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –∫—ç—à–µ–π –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π")
            
            self._last_cache_cleanup = datetime.now()

    def get_aggregate_sentiment(self, symbol: str) -> Dict:
        """–ê–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å –≤–µ—Å–∞–º–∏"""
        
        self._cleanup_old_cache()
        
        cache_key = f"{symbol}_{datetime.now().strftime('%Y%m%d%H')}"
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        weighted_scores = []
        successful_methods = []
        method_scores = []
        
        for method, weight in zip(self.methods, self.weights):
            try:
                result = method(symbol)
                if result and result.get('sentiment_score') is not None:
                    weighted_score = result['sentiment_score'] * weight
                    weighted_scores.append(weighted_score)
                    successful_methods.append(result['method'])
                    method_scores.append(result['sentiment_score'])
            except Exception as e:
                logger.debug(f"Method {method.__name__} failed: {e}")
                continue
        
        if weighted_scores:
            final_score = sum(weighted_scores)
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–∏–ª—É —Å–∏–≥–Ω–∞–ª–∞
            if final_score > 0.25:
                sentiment = 'STRONGLY_BULLISH'
            elif final_score > 0.1:
                sentiment = 'BULLISH' 
            elif final_score < -0.25:
                sentiment = 'STRONGLY_BEARISH'
            elif final_score < -0.1:
                sentiment = 'BEARISH'
            else:
                sentiment = 'NEUTRAL'
            
            confidence = min(len(successful_methods) * 0.3, 0.9)
            
            # –ï—Å–ª–∏ –æ–±—â–∞—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å < 0.2 - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–∞–∫ guard
            if confidence < 0.2:
                sentiment = 'NEUTRAL'
                final_score = 0
            
            result = {
                'sentiment_score': round(final_score, 3),
                'overall_sentiment': sentiment,
                'methods_used': successful_methods,
                'methods_count': len(successful_methods),
                'confidence': confidence,
                'method_scores': method_scores,
                'timestamp': datetime.now().isoformat()
            }
            
            self.cache[cache_key] = result
            return result
        
        return {
            'sentiment_score': 0,
            'overall_sentiment': 'NEUTRAL', 
            'methods_used': [],
            'methods_count': 0,
            'confidence': 0.1,
            'timestamp': datetime.now().isoformat()
        }
    
    def coingecko_sentiment(self, symbol: str) -> Dict:
        """CoinGecko API - –ø–æ–ª–Ω–æ—Å—Ç—å—é –±–µ—Å–ø–ª–∞—Ç–Ω–æ –±–µ–∑ –∫–ª—é—á–∞"""
        
        coin_id_map = {
            'BTC/USDT:USDT': 'bitcoin',
            'ETH/USDT:USDT': 'ethereum', 
            'SOL/USDT:USDT': 'solana',
            'DOGE/USDT:USDT': 'dogecoin',
            'XRP/USDT:USDT': 'ripple',
            'ADA/USDT:USDT': 'cardano',
            'AVAX/USDT:USDT': 'avalanche-2',
            'DOT/USDT:USDT': 'polkadot',
            'LINK/USDT:USDT': 'chainlink',
            'MATIC/USDT:USDT': 'matic-network',
            'BNB/USDT:USDT': 'binancecoin',
            'LTC/USDT:USDT': 'litecoin',
            'ATOM/USDT:USDT': 'cosmos',
            'ETC/USDT:USDT': 'ethereum-classic',
            'BCH/USDT:USDT': 'bitcoin-cash',
            'FIL/USDT:USDT': 'filecoin',
            'NEAR/USDT:USDT': 'near',
            'ALGO/USDT:USDT': 'algorand',
            'VET/USDT:USDT': 'vechain',
            'THETA/USDT:USDT': 'theta-token',
            'EOS/USDT:USDT': 'eos',
            'XTZ/USDT:USDT': 'tezos'
        }
        
        coin_id = coin_id_map.get(symbol)
        if not coin_id:
            return {'sentiment_score': 0, 'method': 'coingecko'}
        
        try:
            # TRENDING API - —Å–∞–º—ã–µ –æ–±—Å—É–∂–¥–∞–µ–º—ã–µ –º–æ–Ω–µ—Ç—ã
            trending_url = "https://api.coingecko.com/api/v3/search/trending"
            trending_response = requests.get(trending_url, timeout=10)
            
            trending_score = 0
            is_trending = False
            if trending_response.status_code == 200:
                trending_data = trending_response.json()
                trending_coins = [coin['item']['id'] for coin in trending_data['coins'][:10]]
                
                # –ï—Å–ª–∏ –Ω–∞—à–∞ –º–æ–Ω–µ—Ç–∞ –≤ —Ç—Ä–µ–Ω–¥–µ - bullish —Å–∏–≥–Ω–∞–ª
                is_trending = coin_id in trending_coins
                trending_score = 0.3 if is_trending else -0.1

            # Community Data
            community_url = f"https://api.coingecko.com/api/v3/coins/{coin_id}?localization=false&tickers=false&community_data=true&developer_data=false"
            community_response = requests.get(community_url, timeout=10)
            
            community_score = 0
            if community_response.status_code == 200:
                community_data = community_response.json()
                
                # –ê–Ω–∞–ª–∏–∑ —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö –º–µ—Ç—Ä–∏–∫
                twitter_followers = community_data.get('community_data', {}).get('twitter_followers', 0)
                reddit_subscribers = community_data.get('community_data', {}).get('reddit_subscribers', 0)
                reddit_active_users = community_data.get('community_data', {}).get('reddit_accounts_active_48h', 0)
                
                # –û—Ü–µ–Ω–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Å–æ–æ–±—â–µ—Å—Ç–≤–∞
                if reddit_active_users > 1000:
                    community_score += 0.2
                elif reddit_active_users > 100:
                    community_score += 0.1
                    
                if twitter_followers > 100000:
                    community_score += 0.1
                    
            final_score = trending_score + community_score
                    
            return {
                'sentiment_score': max(min(final_score, 0.5), -0.3),
                'method': 'coingecko',
                'is_trending': is_trending,
                'social_activity': 'HIGH' if community_score > 0.2 else 'MEDIUM' if community_score > 0.1 else 'LOW'
            }
            
        except Exception as e:
            logger.warning(f"CoinGecko API error: {e}")
            return {'sentiment_score': 0, 'method': 'coingecko'}
    
    def lunarcrush_sentiment(self, symbol: str) -> Dict:
        """LunarCrush - –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –ø–ª–∞–Ω —Å –±–∞–∑–æ–≤—ã–º–∏ –º–µ—Ç—Ä–∏–∫–∞–º–∏"""
        
        coin_symbol_map = {
            'BTC/USDT:USDT': 'BTC',
            'ETH/USDT:USDT': 'ETH',
            'SOL/USDT:USDT': 'SOL', 
            'DOGE/USDT:USDT': 'DOGE',
            'XRP/USDT:USDT': 'XRP',
            'ADA/USDT:USDT': 'ADA',
            'AVAX/USDT:USDT': 'AVAX',
            'DOT/USDT:USDT': 'DOT', 
            'LINK/USDT:USDT': 'LINK',
            'MATIC/USDT:USDT': 'MATIC',
            'BNB/USDT:USDT': 'BNB',
            'LTC/USDT:USDT': 'LTC',
            'ATOM/USDT:USDT': 'ATOM',
            'ETC/USDT:USDT': 'ETC',
            'BCH/USDT:USDT': 'BCH',
            'FIL/USDT:USDT': 'FIL',
            'NEAR/USDT:USDT': 'NEAR',
            'ALGO/USDT:USDT': 'ALGO',
            'VET/USDT:USDT': 'VET',
            'THETA/USDT:USDT': 'THETA',
            'EOS/USDT:USDT': 'EOS',
            'XTZ/USDT:USDT': 'XTZ'
        }
        
        coin_symbol = coin_symbol_map.get(symbol)
        if not coin_symbol:
            return {'sentiment_score': 0, 'method': 'lunarcrush'}
        
        try:
            # –ë–∞–∑–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã –±–µ–∑ –∫–ª—é—á–∞
            url = f"https://lunarcrush.com/api3/coins/{coin_symbol}"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏
                social_impact = data.get('data', {}).get('social_impact', 0)
                social_score = data.get('data', {}).get('social_score', 0)
                social_volume = data.get('data', {}).get('social_volume', 0)
                
                # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º score
                if social_score > 0:
                    normalized_score = min(social_score / 100, 1.0)
                else:
                    normalized_score = 0
                    
                return {
                    'sentiment_score': normalized_score * 0.5,  # Scale down
                    'method': 'lunarcrush', 
                    'social_impact': social_impact,
                    'social_volume': social_volume,
                    'social_score': social_score
                }
                
        except Exception as e:
            logger.warning(f"LunarCrush error: {e}")
        
        return {'sentiment_score': 0, 'method': 'lunarcrush'}
    
    def crypto_news_sentiment(self, symbol: str) -> Dict:
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π —á–µ—Ä–µ–∑ —Å–∫—Ä–∞–ø–∏–Ω–≥ –∫—Ä–∏–ø—Ç–æ-–Ω–æ–≤–æ—Å—Ç–µ–π"""
        
        crypto_name = symbol.replace('/USDT', '').upper()
        
        news_sources = [
            f"https://cointelegraph.com/tags/{crypto_name.lower()}",
            f"https://www.coindesk.com/tag/{crypto_name.lower()}",
            f"https://cryptonews.com/news/{crypto_name.lower()}-news/",
        ]
        
        sentiment_scores = []
        
        for url in news_sources:
            try:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                }
                
                response = requests.get(url, headers=headers, timeout=15)
                if response.status_code == 200:
                    soup = BeautifulSoup(response.content, 'html.parser')
                    text_content = soup.get_text().lower()
                    
                    # –£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
                    positive_indicators = [
                        'partnership', 'adoption', 'integration', 'launch', 'update', 'upgrade',
                        'bullish', 'surge', 'rally', 'breakout', 'growth', 'positive', 'optimistic',
                        'success', 'win', 'gain', 'profit', 'recovery', 'rebound', 'soar',
                        'institutional', 'adoption', 'partnership', 'listing', 'burn'
                    ]
                    
                    negative_indicators = [
                        'hack', 'exploit', 'delay', 'lawsuit', 'regulation', 'bearish', 'ban',
                        'drop', 'crash', 'warning', 'risk', 'negative', 'concern', 'fud',
                        'loss', 'fail', 'problem', 'issue', 'down', 'sell-off', 'dump',
                        'investigation', 'sec', 'legal', 'bankruptcy', 'liquidation'
                    ]
                    
                    # –í–∑–≤–µ—à–µ–Ω–Ω—ã–π –ø–æ–¥—Å—á–µ—Ç
                    positive_count = sum(2 for word in positive_indicators if word in text_content)
                    negative_count = sum(2 for word in negative_indicators if word in text_content)
                    
                    # –£—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ —Å–ª–æ–≤–∞
                    strong_positive = ['moon', 'rocket', 'explode', 'breakout']
                    strong_negative = ['collapse', 'plummet', 'crash', 'doom']
                    
                    positive_count += sum(3 for word in strong_positive if word in text_content)
                    negative_count += sum(3 for word in strong_negative if word in text_content)
                    
                    total = positive_count + negative_count
                    if total > 0:
                        score = (positive_count - negative_count) / total
                        sentiment_scores.append(min(max(score, -1), 1))  # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
                        
            except Exception as e:
                logger.debug(f"News scraping failed for {url}: {e}")
                continue
        
        if sentiment_scores:
            avg_score = sum(sentiment_scores) / len(sentiment_scores)
            return {
                'sentiment_score': avg_score,
                'method': 'crypto_news',
                'sources_analyzed': len(sentiment_scores)
            }
        
        return {'sentiment_score': 0, 'method': 'crypto_news'}

class BybitFuturesTrader:
    def __init__(self, api_key: str, secret: str, testnet: bool = False):
        self.exchange = ccxt.bybit({
            'apiKey': api_key,
            'secret': secret,
            'sandbox': testnet,
            'enableRateLimit': True,
            'options': {
                'defaultType': 'linear',
                'adjustForTimeDifference': True,
                'recvWindow': 10000,
            }
        })
        self.last_trade_time = {}
        self.symbol_precision = {}
        self.max_open_positions = 5
        self._last_memory_cleanup = datetime.now()
        logger.info("Bybit Futures Trader –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

    def _cleanup_old_data(self):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —É—Ç–µ—á–µ–∫ –ø–∞–º—è—Ç–∏"""
        if (datetime.now() - self._last_memory_cleanup) > timedelta(hours=1):
            current_time = datetime.now()
            keys_to_remove = []
            
            for symbol, last_time in list(self.last_trade_time.items()):
                if (current_time - last_time) > timedelta(hours=6):
                    keys_to_remove.append(symbol)
            
            for symbol in keys_to_remove:
                if symbol in self.last_trade_time:
                    del self.last_trade_time[symbol]
                if symbol in self.symbol_precision:
                    del self.symbol_precision[symbol]
            
            if keys_to_remove:
                logger.info(f"üßπ –û—á–∏—â–µ–Ω–æ {len(keys_to_remove)} —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –∑–∞–ø–∏—Å–µ–π —Ç—Ä–µ–π–¥–µ—Ä–∞")
            
            self._last_memory_cleanup = datetime.now()

    def set_leverage(self, symbol: str, leverage: int):
        try:
            clean_symbol = self._clean_symbol(symbol)
            self.exchange.set_leverage(leverage, clean_symbol, params={'category': 'linear'})
            logger.info(f"–ü–ª–µ—á–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {clean_symbol} x{leverage}")
            return True
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª–µ—á–∞: {e}")
            return True

    def _clean_symbol(self, symbol: str) -> str:
        if ':' in symbol:
            symbol = symbol.split(':')[0]
        clean = symbol.replace('/', '')
        if not clean.endswith('USDT'):
            clean += 'USDT'
        return clean

    def get_symbol_precision(self, symbol: str) -> float:
        try:
            if symbol in self.symbol_precision:
                return self.symbol_precision[symbol]
            
            clean_symbol = self._clean_symbol(symbol)
            markets = self.exchange.load_markets()
            market = markets.get(clean_symbol)
            
            if market and 'precision' in market and 'amount' in market['precision']:
                precision = market['precision']['amount']
                min_amount = 10 ** -precision if precision > 0 else 0.1
                self.symbol_precision[symbol] = min_amount
                logger.info(f"–¢–æ—á–Ω–æ—Å—Ç—å –¥–ª—è {symbol}: {min_amount}")
                return min_amount
            
            default_precisions = {
                'BTC/USDT:USDT': 0.001,
                'ETH/USDT:USDT': 0.01,
                'SOL/USDT:USDT': 0.1,
                'XRP/USDT:USDT': 1,
                'ADA/USDT:USDT': 1,
                'AVAX/USDT:USDT': 0.1,
                'DOGE/USDT:USDT': 1,
                'DOT/USDT:USDT': 0.1,
                'LINK/USDT:USDT': 0.1,
                'MATIC/USDT:USDT': 1,
                'BNB/USDT:USDT': 0.01,
                'LTC/USDT:USDT': 0.01,
                'ATOM/USDT:USDT': 0.1,
                'ETC/USDT:USDT': 0.1,
                'BCH/USDT:USDT': 0.001,
                'FIL/USDT:USDT': 0.1,
                'NEAR/USDT:USDT': 0.1,
                'ALGO/USDT:USDT': 1,
                'VET/USDT:USDT': 1,
                'THETA/USDT:USDT': 1,
                'EOS/USDT:USDT': 0.1,
                'XTZ/USDT:USDT': 0.1,
            }
            
            min_amount = default_precisions.get(symbol, 0.1)
            self.symbol_precision[symbol] = min_amount
            return min_amount
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ—á–Ω–æ—Å—Ç–∏ –¥–ª—è {symbol}: {e}")
            return 0.1

    def adjust_amount_to_precision(self, symbol: str, amount: float) -> float:
        min_amount = self.get_symbol_precision(symbol)
        adjusted_amount = max(amount, min_amount)
        
        if min_amount >= 1:
            adjusted_amount = int(adjusted_amount)
        elif min_amount >= 0.1:
            adjusted_amount = round(adjusted_amount, 1)
        elif min_amount >= 0.01:
            adjusted_amount = round(adjusted_amount, 2)
        elif min_amount >= 0.001:
            adjusted_amount = round(adjusted_amount, 3)
        else:
            adjusted_amount = round(adjusted_amount, 4)
        
        if adjusted_amount != amount:
            logger.info(f"–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω —Ä–∞–∑–º–µ—Ä {symbol}: {amount} -> {adjusted_amount}")
        
        return adjusted_amount

    def get_balance(self):
        try:
            balance = self.exchange.fetch_balance({'type': 'UNIFIED'})
            usdt_balance = balance.get('USDT', {}).get('free', 0) or balance.get('total', {}).get('USDT', 0)
            final_balance = float(usdt_balance) if usdt_balance else 0.0
            logger.info(f"–ë–∞–ª–∞–Ω—Å: {final_balance} USDT")
            return final_balance
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e}")
            return 0.0

    def create_order(self, symbol: str, order_type: str, side: str, amount: float, price: float = None, take_profit: float = None, stop_loss: float = None):
        try:
            current_time = datetime.now()
            if symbol in self.last_trade_time:
                time_since_last_trade = current_time - self.last_trade_time[symbol]
                if time_since_last_trade < timedelta(minutes=3):
                    logger.warning(f"–°–ª–∏—à–∫–æ–º —á–∞—Å—Ç–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è –¥–ª—è {symbol}. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º.")
                    return None

            clean_symbol = self._clean_symbol(symbol)
            current_price = price or self.get_ticker(symbol)
            
            if current_price <= 0:
                logger.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Ü–µ–Ω–∞ –¥–ª—è {symbol}: {current_price}")
                return None

            balance = self.get_balance()
            
            adjusted_amount = self.adjust_amount_to_precision(symbol, amount)
            
            if adjusted_amount < self.get_symbol_precision(symbol):
                logger.error(f"–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–∞–∑–º–µ—Ä —Å–ª–∏—à–∫–æ–º –º–∞–ª –¥–ª—è {symbol}: {adjusted_amount}")
                return None

            order_value = adjusted_amount * current_price
            
            if balance < 100:
                required_margin = order_value * 0.05
            else:
                required_margin = order_value * 0.1
                
            if balance < required_margin:
                logger.error(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–ª–∞–Ω—Å–∞: {balance} < {required_margin}")
                return None

            positions = self.get_positions()
            if len(positions) >= self.max_open_positions:
                logger.warning(f"–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π: {len(positions)}/{self.max_open_positions}")
                return None

            # –§–∏–∫—Å SL/TP
            if side == 'buy':
                if stop_loss and stop_loss >= current_price:
                    stop_loss = current_price * 0.99
                    logger.warning(f"–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω SL –¥–ª—è BUY: {stop_loss}")
                if take_profit and take_profit <= current_price:
                    take_profit = current_price * 1.01
                    logger.warning(f"–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω TP –¥–ª—è BUY: {take_profit}")
            elif side == 'sell':
                if stop_loss and stop_loss <= current_price:
                    stop_loss = current_price * 1.01
                    logger.warning(f"–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω SL –¥–ª—è SELL: {stop_loss}")
                if take_profit and take_profit >= current_price:
                    take_profit = current_price * 0.99
                    logger.warning(f"–°–∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω TP –¥–ª—è SELL: {take_profit}")

            params = {'category': 'linear', 'timeInForce': 'GTC'}
            
            if take_profit:
                params['takeProfit'] = take_profit
            if stop_loss:
                params['stopLoss'] = stop_loss

            logger.info(f"–°–æ–∑–¥–∞–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞: {clean_symbol} {side} {adjusted_amount} @ {current_price} | TP: {take_profit} SL: {stop_loss}")
            
            order = self.exchange.create_order(
                symbol=clean_symbol, type=order_type, side=side,
                amount=adjusted_amount, params=params
            )

            self.last_trade_time[symbol] = current_time
            logger.info(f"–û–†–î–ï–† –ò–°–ü–û–õ–ù–ï–ù: {side} {adjusted_amount} {clean_symbol} @ {current_price:.4f}")
            return order
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ä–¥–µ—Ä–∞: {e}")
            return None

    def get_ticker(self, symbol: str):
        try:
            clean_symbol = self._clean_symbol(symbol)
            ticker = self.exchange.fetch_ticker(clean_symbol)
            price = float(ticker.get('last', 0))
            return price
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã {symbol}: {e}")
            return 0.0

    def get_positions(self):
        try:
            positions = self.exchange.fetch_positions(None, {'category': 'linear'})
            active_positions = []
            for pos in positions:
                if pos['contracts'] and float(pos['contracts']) > 0:
                    active_positions.append({
                        'symbol': pos['symbol'],
                        'side': 'long' if float(pos['contracts']) > 0 else 'short',
                        'size': float(pos['contracts']),
                        'entry_price': float(pos['entryPrice']),
                        'unrealized_pnl': float(pos.get('unrealizedPnl', 0)),
                        'leverage': float(pos.get('leverage', 1))
                    })
            return active_positions
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π: {e}")
            return []

    def get_open_orders(self, symbol: str = None):
        try:
            params = {'category': 'linear'}
            if symbol:
                clean_symbol = self._clean_symbol(symbol)
                orders = self.exchange.fetch_open_orders(clean_symbol, params=params)
            else:
                orders = self.exchange.fetch_open_orders(params=params)
            return orders
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–æ–≤: {e}")
            return []

    def get_account_info(self):
        """üîß –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø –ë–ï–ó –†–ï–ö–£–†–°–ò–ò"""
        try:
            self._cleanup_old_data()
            
            balance = self.get_balance()
            positions = self.get_positions()
            orders = self.get_open_orders()
            
            total_margin_used = 0
            total_unrealized_pnl = 0
            
            for pos in positions:
                try:
                    size = float(pos.get('size', 0))
                    entry_price = float(pos.get('entry_price', 0))
                    leverage = max(float(pos.get('leverage', 1)), 1)
                    
                    if size > 0 and entry_price > 0:
                        total_margin_used += (size * entry_price) / leverage
                    total_unrealized_pnl += pos.get('unrealized_pnl', 0)
                except (ValueError, TypeError) as e:
                    logger.warning(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –º–∞—Ä–∂–∏ –¥–ª—è –ø–æ–∑–∏—Ü–∏–∏: {e}")
                    continue
            
            available_balance = max(balance - total_margin_used, 0)
            
            return {
                'total_balance': balance,
                'available_balance': available_balance,
                'margin_used': total_margin_used,
                'positions_count': len(positions),
                'orders_count': len(orders),
                'unrealized_pnl': total_unrealized_pnl,
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏: {e}")
            return {
                'total_balance': 0.0, 'available_balance': 0.0, 'margin_used': 0.0,
                'positions_count': 0, 'orders_count': 0, 'unrealized_pnl': 0.0
            }

class AdvancedTechnicalAnalyzer:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Å ADX"""
    
    def __init__(self):
        self._analysis_cache = {}
        self._last_cache_cleanup = datetime.now()
        logger.info("Advanced Technical Analyzer –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def _cleanup_old_cache(self):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –∫—ç—à–∞ –∞–Ω–∞–ª–∏–∑–∞"""
        if (datetime.now() - self._last_cache_cleanup) > timedelta(minutes=30):
            keys_to_remove = []
            current_time = datetime.now()
            
            for key in list(self._analysis_cache.keys()):
                cache_data = self._analysis_cache.get(key, {})
                if isinstance(cache_data, dict) and 'timestamp' in cache_data:
                    try:
                        cache_time = datetime.fromisoformat(cache_data['timestamp'])
                        if (current_time - cache_time) > timedelta(hours=1):
                            keys_to_remove.append(key)
                    except:
                        keys_to_remove.append(key)
            
            for key in keys_to_remove:
                if key in self._analysis_cache:
                    del self._analysis_cache[key]
            
            if keys_to_remove:
                logger.debug(f"üßπ –û—á–∏—â–µ–Ω–æ {len(keys_to_remove)} —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –∫—ç—à–µ–π –∞–Ω–∞–ª–∏–∑–∞")
            
            self._last_cache_cleanup = datetime.now()

    def get_multi_timeframe_analysis(self, symbol: str, exchange) -> Dict:
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–∞–π–º—Ñ—Ä–µ–π–º–∞—Ö —Å ADX"""
        
        self._cleanup_old_cache()
        
        cache_key = f"{symbol}_analysis"
        cached_data = self._analysis_cache.get(cache_key)
        
        if cached_data and (datetime.now() - datetime.fromisoformat(cached_data.get('timestamp', '2000-01-01'))) < timedelta(minutes=5):
            return cached_data['data']
        
        try:
            clean_symbol = self._clean_symbol(symbol)
            
            analysis = {}
            
            # 1. –î–û–õ–ì–û–°–†–û–ß–ù–´–ô —Ç—Ä–µ–Ω–¥ (4h, 1d) - –¥–ª—è Grok
            analysis['trend'] = self._analyze_primary_trend(clean_symbol, exchange)
            
            # 2. –°–†–ï–î–ù–ï–°–†–û–ß–ù–´–ô —Å–∏–≥–Ω–∞–ª (1h) - –¥–ª—è –≤—Ö–æ–¥–∞ —Å ADX
            analysis['entry'] = self._analyze_entry_signals(clean_symbol, exchange)
            
            # 3. –ö–†–ê–¢–ö–û–°–†–û–ß–ù–´–ô –≤—Ö–æ–¥ (15m) - –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
            analysis['execution'] = self._analyze_execution_signals(clean_symbol, exchange)
            
            # 4. –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –∏ —Ä–∏—Å–∫ —Å ADX
            analysis['risk'] = self._analyze_risk_parameters(clean_symbol, exchange)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
            self._analysis_cache[cache_key] = {
                'data': analysis,
                'timestamp': datetime.now().isoformat()
            }
            
            return analysis
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ multi-timeframe –∞–Ω–∞–ª–∏–∑–∞ {symbol}: {e}")
            return self._get_fallback_analysis()
    
    def _analyze_primary_trend(self, symbol: str, exchange) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ç—Ä–µ–Ω–¥–∞ –Ω–∞ 4h/1d —Å ADX"""
        try:
            ohlcv_4h = exchange.fetch_ohlcv(symbol, '4h', limit=100)
            ohlcv_1d = exchange.fetch_ohlcv(symbol, '1d', limit=100)
            
            if not ohlcv_4h or not ohlcv_1d:
                return {'trend': 'NEUTRAL', 'strength': 0.5, 'timeframe': '4h', 'adx': 0}
            
            df_4h = pd.DataFrame(ohlcv_4h, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df_1d = pd.DataFrame(ohlcv_1d, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # EMA –∞–Ω–∞–ª–∏–∑ –¥–ª—è —Ç—Ä–µ–Ω–¥–∞
            df_4h['ema_20'] = ta.ema(df_4h['close'], length=20)
            df_4h['ema_50'] = ta.ema(df_4h['close'], length=50)
            df_1d['ema_20'] = ta.ema(df_1d['close'], length=20)
            df_1d['ema_50'] = ta.ema(df_1d['close'], length=50)
            
            # ADX –¥–ª—è —Å–∏–ª—ã —Ç—Ä–µ–Ω–¥–∞
            df_4h_adx = ta.adx(df_4h['high'], df_4h['low'], df_4h['close'], length=14)
            df_1d_adx = ta.adx(df_1d['high'], df_1d['low'], df_1d['close'], length=14)
            
            adx_4h = df_4h_adx['ADX_14'].iloc[-1] if not df_4h_adx.empty else 0
            adx_1d = df_1d_adx['ADX_14'].iloc[-1] if not df_1d_adx.empty else 0
            
            # –°–∏–ª–∞ —Ç—Ä–µ–Ω–¥–∞ —Å —É—á–µ—Ç–æ–º ADX
            trend_strength_4h = self._calculate_trend_strength(df_4h, adx_4h)
            trend_strength_1d = self._calculate_trend_strength(df_1d, adx_1d)
            
            # –°–æ–≤–º–µ—â–µ–Ω–Ω—ã–π —Ç—Ä–µ–Ω–¥
            combined_strength = (trend_strength_4h + trend_strength_1d) / 2
            
            if combined_strength > 0.6:
                trend = "BULLISH"
            elif combined_strength < -0.6:
                trend = "BEARISH"
            else:
                trend = "RANGING"
            
            avg_adx = (adx_4h + adx_1d) / 2
            
            return {
                'trend': trend,
                'strength': abs(combined_strength),
                'timeframe': '4h/1d',
                'price_4h': df_4h['close'].iloc[-1],
                'price_1d': df_1d['close'].iloc[-1],
                'adx': avg_adx,
                'adx_strength': 'STRONG' if avg_adx > 25 else 'MODERATE' if avg_adx > 20 else 'WEAK'
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–µ–Ω–¥–∞: {e}")
            return {'trend': 'NEUTRAL', 'strength': 0.5, 'timeframe': '4h', 'adx': 0}
    
    def _analyze_entry_signals(self, symbol: str, exchange) -> Dict:
        """–£–õ–£–ß–®–ï–ù–ù–´–ô –∞–Ω–∞–ª–∏–∑ —Å–∏–≥–Ω–∞–ª–æ–≤ –≤—Ö–æ–¥–∞ —Å –¥–µ—Ç–∞–ª—å–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–æ–π"""
        try:
            ohlcv_1h = exchange.fetch_ohlcv(symbol, '1h', limit=50)
            
            if not ohlcv_1h or len(ohlcv_1h) < 20:
                return {'action': 'HOLD', 'confidence': 0.5, 'reason': 'Insufficient data'}
            
            df = pd.DataFrame(ohlcv_1h, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –¥–ª—è –∫—Ä–∏–ø—Ç–æ
            df['rsi'] = ta.rsi(df['close'], length=14)
            df['macd'] = ta.macd(df['close'])['MACD_12_26_9']
            
            # ADX –¥–ª—è —Å–∏–ª—ã —Ç—Ä–µ–Ω–¥–∞
            adx_data = ta.adx(df['high'], df['low'], df['close'], length=14)
            df['adx'] = adx_data['ADX_14']
            
            df['bb_upper'] = ta.bbands(df['close'], length=20, std=2)['BBU_20_2.0']
            df['bb_lower'] = ta.bbands(df['close'], length=20, std=2)['BBL_20_2.0']
            df['atr'] = ta.atr(df['high'], df['low'], df['close'], length=14)
            
            current_rsi = df['rsi'].iloc[-1]
            current_macd = df['macd'].iloc[-1]
            current_price = df['close'].iloc[-1]
            atr = df['atr'].iloc[-1]
            current_adx = df['adx'].iloc[-1]
            
            # –£–õ–£–ß–®–ï–ù–ù–ê–Ø —Å–∏—Å—Ç–µ–º–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ —Å –≤–µ—Å–∞–º–∏
            buy_signals = 0
            sell_signals = 0
            
            # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ RSI —Å–∏–≥–Ω–∞–ª—ã (—Ä–∞—Å—Å–ª–∞–±–ª–µ–Ω–Ω—ã–µ thresholds)
            if current_rsi < 35:
                buy_signals += 2
            elif current_rsi < 45:
                buy_signals += 1
            elif current_rsi > 65:
                sell_signals += 2
            elif current_rsi > 55:
                sell_signals += 1
            
            # MACD —Å–∏–≥–Ω–∞–ª—ã
            if current_macd > 0 and df['macd'].iloc[-2] <= 0:
                buy_signals += 1
            elif current_macd < 0 and df['macd'].iloc[-2] >= 0:
                sell_signals += 1
            
            # Bollinger Bands
            if current_price <= df['bb_lower'].iloc[-1]:
                buy_signals += 1
            elif current_price >= df['bb_upper'].iloc[-1]:
                sell_signals += 1
            
            # ADX —Ñ–∏–ª—å—Ç—Ä - —É—Å–∏–ª–∏–≤–∞–µ–º —Å–∏–≥–Ω–∞–ª—ã –ø—Ä–∏ —Å–∏–ª—å–Ω–æ–º —Ç—Ä–µ–Ω–¥–µ
            adx_multiplier = 1.5 if current_adx > 25 else 1.2 if current_adx > 20 else 1.0
            
            # –í–ó–í–ï–®–ï–ù–ù–ê–Ø —Å–∏—Å—Ç–µ–º–∞ –≤–º–µ—Å—Ç–æ –ø—Ä–æ—Å—Ç–æ–≥–æ –ø–æ–¥—Å—á–µ—Ç–∞
            weighted_buy_score = (buy_signals * adx_multiplier)
            weighted_sell_score = (sell_signals * adx_multiplier)
            
            # –£–õ–£–ß–®–ï–ù–ù–´–ï —É—Å–ª–æ–≤–∏—è –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π (–æ—Å–ª–∞–±–ª–µ–Ω–Ω—ã–µ –ø–æ—Ä–æ–≥–∏)
            if weighted_buy_score >= 2.0:  # –ë—ã–ª–æ 3.0
                action = 'BUY'
                confidence = min((weighted_buy_score + 1) / 5.0, 0.9)  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
            elif weighted_sell_score >= 2.0:  # –ë—ã–ª–æ 3.0
                action = 'SELL'
                confidence = min((weighted_sell_score + 1) / 5.0, 0.9)  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
            else:
                action = 'HOLD'
                confidence = 0.3
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –±—É—Å—Ç –¥–ª—è —Å–∏–ª—å–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤
            if (action == 'BUY' and buy_signals >= 3) or (action == 'SELL' and sell_signals >= 3):
                confidence = min(confidence * 1.2, 0.95)
            
            # üîç –î–ï–¢–ê–õ–¨–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê - –î–û–ë–ê–í–õ–ï–ù–û
            logger.info(f"üîç [DIAGNOSTIC] {symbol} - –¢–µ—Ö.–∞–Ω–∞–ª–∏–∑ –¥–µ—Ç–∞–ª–∏:")
            logger.info(f"   üìä –¶–µ–Ω–∞: {current_price:.4f}, RSI: {current_rsi:.1f}")
            logger.info(f"   üìà MACD: {current_macd:.6f}, ADX: {current_adx:.1f}")
            logger.info(f"   üìâ ATR: {atr:.4f}")
            
            # –ê–Ω–∞–ª–∏–∑ –ø–æ–ª–æ–∂–µ–Ω–∏—è –≤ Bollinger Bands
            bb_position = ((current_price - df['bb_lower'].iloc[-1]) / 
                          (df['bb_upper'].iloc[-1] - df['bb_lower'].iloc[-1]))
            logger.info(f"   üéØ BB Position: {bb_position:.2f} (0=lower, 1=upper)")
            
            logger.info(f"   ‚úÖ BUY —Å—ã—Ä—ã–µ —Å–∏–≥–Ω–∞–ª—ã: {buy_signals}")
            logger.info(f"   ‚ùå SELL —Å—ã—Ä—ã–µ —Å–∏–≥–Ω–∞–ª—ã: {sell_signals}")
            logger.info(f"   üéØ Weighted scores: BUY={weighted_buy_score:.2f}, SELL={weighted_sell_score:.2f}")
            logger.info(f"   üìã Final decision: {action} (conf: {confidence:.2f})")
            
            return {
                'action': action,
                'confidence': confidence,
                'rsi': current_rsi,
                'macd': current_macd,
                'atr': atr,
                'adx': current_adx,
                'price': current_price,
                'signals': {
                    'buy': weighted_buy_score, 
                    'sell': weighted_sell_score,
                    'raw_buy': buy_signals,
                    'raw_sell': sell_signals
                }
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –≤—Ö–æ–¥–∞: {e}")
            return {'action': 'HOLD', 'confidence': 0.3, 'reason': 'Analysis error'}
    
    def _analyze_execution_signals(self, symbol: str, exchange) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–∞ 15m"""
        try:
            ohlcv_15m = exchange.fetch_ohlcv(symbol, '15m', limit=30)
            
            if not ohlcv_15m or len(ohlcv_15m) < 10:
                return {'optimal_entry': None, 'confidence': 0.5}
            
            df = pd.DataFrame(ohlcv_15m, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # –ê–Ω–∞–ª–∏–∑ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –≤—Ö–æ–¥–∞
            df['ema_9'] = ta.ema(df['close'], length=9)
            df['ema_21'] = ta.ema(df['close'], length=21)
            df['rsi_14'] = ta.rsi(df['close'], length=14)
            
            current_price = df['close'].iloc[-1]
            ema_9 = df['ema_9'].iloc[-1]
            ema_21 = df['ema_21'].iloc[-1]
            rsi = df['rsi_14'].iloc[-1]
            
            # –õ–æ–≥–∏–∫–∞ —Ç–æ—á–Ω–æ–≥–æ –≤—Ö–æ–¥–∞
            if ema_9 > ema_21 and rsi < 60:
                # –ë—ã—á–∏–π —Ç—Ä–µ–Ω–¥, –∂–¥–µ–º –æ—Ç–∫–∞—Ç–∞
                optimal_entry = max(df['low'].tail(5).min(), ema_21)
                confidence = 0.7
            elif ema_9 < ema_21 and rsi > 40:
                # –ú–µ–¥–≤–µ–∂–∏–π —Ç—Ä–µ–Ω–¥, –∂–¥–µ–º –æ—Ç—Å–∫–æ–∫–∞
                optimal_entry = min(df['high'].tail(5).max(), ema_21)
                confidence = 0.7
            else:
                optimal_entry = current_price
                confidence = 0.4
            
            return {
                'optimal_entry': optimal_entry,
                'confidence': confidence,
                'current_price': current_price,
                'distance_pct': abs((optimal_entry - current_price) / current_price * 100)
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è: {e}")
            return {'optimal_entry': None, 'confidence': 0.3}
    
    def _analyze_risk_parameters(self, symbol: str, exchange) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ —Ä–∏—Å–∫–∞ —Å ADX"""
        try:
            ohlcv_1h = exchange.fetch_ohlcv(symbol, '1h', limit=50)
            
            if not ohlcv_1h:
                return {'atr': 0, 'volatility': 'LOW', 'risk_level': 'MEDIUM', 'adx': 0}
            
            df = pd.DataFrame(ohlcv_1h, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # ATR –¥–ª—è —Å—Ç–æ–ø-–ª–æ—Å—Å–∞
            atr = ta.atr(df['high'], df['low'], df['close'], length=14).iloc[-1]
            
            # ADX –¥–ª—è —Å–∏–ª—ã —Ç—Ä–µ–Ω–¥–∞
            adx_data = ta.adx(df['high'], df['low'], df['close'], length=14)
            adx = adx_data['ADX_14'].iloc[-1] if not adx_data.empty else 0
            
            # –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
            price_changes = df['close'].pct_change().dropna()
            volatility = price_changes.std() * np.sqrt(24)
            
            if volatility > 0.8:
                vol_level = 'HIGH'
                risk_level = 'HIGH'
            elif volatility > 0.4:
                vol_level = 'MEDIUM'
                risk_level = 'MEDIUM'
            else:
                vol_level = 'LOW'
                risk_level = 'LOW'
            
            # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –º–Ω–æ–∂–∏—Ç–µ–ª—å SL –Ω–∞ –æ—Å–Ω–æ–≤–µ ADX
            if adx > 25:
                sl_multiplier = 1.2
                position_size_multiplier = 1.2
            elif adx > 20:
                sl_multiplier = 1.5
                position_size_multiplier = 1.0
            else:
                sl_multiplier = 2.0
                position_size_multiplier = 0.8
            
            return {
                'atr': atr,
                'volatility': vol_level,
                'risk_level': risk_level,
                'volatility_value': volatility,
                'adx': adx,
                'recommended_sl_multiplier': sl_multiplier,
                'position_size_multiplier': position_size_multiplier
            }
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ä–∏—Å–∫–∞: {e}")
            return {'atr': 0, 'volatility': 'LOW', 'risk_level': 'MEDIUM', 'adx': 0}
    
    def _calculate_trend_strength(self, df: pd.DataFrame, adx: float) -> float:
        """–†–∞—Å—á–µ—Ç —Å–∏–ª—ã —Ç—Ä–µ–Ω–¥–∞ —Å —É—á–µ—Ç–æ–º ADX"""
        try:
            ema_20 = ta.ema(df['close'], length=20)
            ema_50 = ta.ema(df['close'], length=50)
            sma_20 = ta.sma(df['close'], length=20)
            
            current_ema_20 = ema_20.iloc[-1]
            current_ema_50 = ema_50.iloc[-1]
            current_sma_20 = sma_20.iloc[-1]
            current_price = df['close'].iloc[-1]
            
            ema_trend = 1 if current_ema_20 > current_ema_50 else -1
            price_vs_sma = (current_price - current_sma_20) / current_sma_20
            adx_strength = min(adx / 50.0, 1.0)
            
            trend_strength = ema_trend * (0.6 + abs(price_vs_sma) * 2 + adx_strength * 0.5)
            
            return max(min(trend_strength, 1), -1)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Å–∏–ª—ã —Ç—Ä–µ–Ω–¥–∞: {e}")
            return 0.0
    
    def _clean_symbol(self, symbol: str) -> str:
        if ':' in symbol:
            symbol = symbol.split(':')[0]
        clean = symbol.replace('/', '')
        if not clean.endswith('USDT'):
            clean += 'USDT'
        return clean
    
    def _get_fallback_analysis(self) -> Dict:
        return {
            'trend': {'trend': 'NEUTRAL', 'strength': 0.5, 'timeframe': '4h', 'adx': 0},
            'entry': {'action': 'HOLD', 'confidence': 0.3, 'reason': 'Fallback'},
            'execution': {'optimal_entry': None, 'confidence': 0.3},
            'risk': {'atr': 0, 'volatility': 'LOW', 'risk_level': 'MEDIUM', 'adx': 0}
        }

class GrokTrendFilter:
    """Grok –∫–∞–∫ —Ñ–∏–ª—å—Ç—Ä –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–≥–æ —Ç—Ä–µ–Ω–¥–∞"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.endpoint = "https://api.x.ai/v1/chat/completions"
        self.last_analysis_time = {}
        self.cache = {}
        self.daily_calls = 0
        self.max_daily_calls = 20
        self.last_reset_day = datetime.now().date()
        self.initial_analysis_done = False
        self._last_cache_cleanup = datetime.now()
        logger.info("Grok Trend Filter –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def _cleanup_old_cache(self):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä–æ–≥–æ –∫—ç—à–∞ Grok"""
        if (datetime.now() - self._last_cache_cleanup) > timedelta(hours=1):
            keys_to_remove = []
            current_time = datetime.now()
            current_date = current_time.strftime('%Y%m%d')
            
            for key in list(self.cache.keys()):
                if not key.endswith(current_date):
                    keys_to_remove.append(key)
            
            # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –≤—Ä–µ–º–µ–Ω–∏ –∞–Ω–∞–ª–∏–∑–∞
            symbols_to_remove = []
            for symbol, last_time in list(self.last_analysis_time.items()):
                if (current_time - last_time) > timedelta(days=1):
                    symbols_to_remove.append(symbol)
            
            for key in keys_to_remove:
                if key in self.cache:
                    del self.cache[key]
            
            for symbol in symbols_to_remove:
                if symbol in self.last_analysis_time:
                    del self.last_analysis_time[symbol]
            
            if keys_to_remove or symbols_to_remove:
                logger.info(f"üßπ –û—á–∏—â–µ–Ω–æ {len(keys_to_remove)} –∫—ç—à–µ–π –∏ {len(symbols_to_remove)} –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫ Grok")
            
            self._last_cache_cleanup = datetime.now()

    def _reset_daily_counter(self):
        today = datetime.now().date()
        if today != self.last_reset_day:
            self.daily_calls = 0
            self.last_reset_day = today
    
    def perform_initial_analysis(self, symbols: List[str], technical_analyzer, exchange) -> Dict[str, Dict]:
        """–ü—Ä–æ–≤–µ–¥–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞"""
        logger.info("üéØ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ Grok –¥–ª—è –≤—Å–µ—Ö —Å–∏–º–≤–æ–ª–æ–≤...")
        
        initial_analysis = {}
        successful_analyses = 0
        
        for symbol in symbols:
            try:
                logger.info(f"üîç –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ Grok –¥–ª—è {symbol}...")
                
                # –ü–æ–ª—É—á–∞–µ–º —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
                technical_data = technical_analyzer.get_multi_timeframe_analysis(symbol, exchange)
                
                # –ê–Ω–∞–ª–∏–∑ Grok (–±–µ–∑ —É—á–µ—Ç–∞ –≤ –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç)
                analysis = self._analyze_primary_trend_internal(symbol, technical_data, is_initial=True)
                
                if analysis.get('grok_analysis', False):
                    initial_analysis[symbol] = analysis
                    successful_analyses += 1
                    logger.info(f"‚úÖ –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ Grok –¥–ª—è {symbol} –∑–∞–≤–µ—Ä—à–µ–Ω: {analysis.get('trend')}")
                else:
                    logger.warning(f"‚ùå –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ Grok –¥–ª—è {symbol} –Ω–µ —É–¥–∞–ª—Å—è")
                
                # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏ —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞—Ç—å API
                time.sleep(2)
                
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è {symbol}: {e}")
                continue
        
        self.initial_analysis_done = True
        logger.info(f"üéØ –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à–µ–Ω: {successful_analyses}/{len(symbols)} —Å–∏–º–≤–æ–ª–æ–≤")
        
        return initial_analysis
    
    def analyze_primary_trend(self, symbol: str, technical_data: Dict) -> Dict:
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–µ–Ω–¥–∞ Grok (—É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –≤ –¥–Ω–µ–≤–Ω–æ–º –ª–∏–º–∏—Ç–µ)"""
        
        self._cleanup_old_cache()
        self._reset_daily_counter()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö –∞–Ω–∞–ª–∏–∑–æ–≤, –Ω–µ –¥–ª—è –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã—Ö)
        if self.daily_calls >= self.max_daily_calls and self.initial_analysis_done:
            logger.warning(f"üö´ –î–æ—Å—Ç–∏–≥–Ω—É—Ç –¥–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç –≤—ã–∑–æ–≤–æ–≤ Grok: {self.daily_calls}/{self.max_daily_calls}")
            return {'trend': 'NEUTRAL', 'confidence': 0.5, 'reasoning': 'Daily limit reached', 'grok_analysis': False}
        
        return self._analyze_primary_trend_internal(symbol, technical_data, is_initial=False)
    
    def _analyze_primary_trend_internal(self, symbol: str, technical_data: Dict, is_initial: bool = False) -> Dict:
        """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–µ—Ç–æ–¥ –∞–Ω–∞–ª–∏–∑–∞ —Ç—Ä–µ–Ω–¥–∞ Grok"""
        
        cache_key = f"{symbol}_{datetime.now().strftime('%Y%m%d')}"
        if cache_key in self.cache and not is_initial:
            return self.cache[cache_key]
        
        # Cooldown –ø—Ä–æ–≤–µ—Ä–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö –∞–Ω–∞–ª–∏–∑–æ–≤)
        current_time = datetime.now()
        if not is_initial and symbol in self.last_analysis_time:
            time_since_analysis = current_time - self.last_analysis_time[symbol]
            if time_since_analysis < timedelta(hours=6):
                cached_result = self.cache.get(cache_key, {'trend': 'NEUTRAL', 'confidence': 0.5})
                if cached_result.get('grok_analysis', False):
                    return cached_result
        
        try:
            trend_info = technical_data['trend']
            entry_info = technical_data['entry']
            risk_info = technical_data['risk']
            
            prompt = f"""
–ê–Ω–∞–ª–∏–∑ –î–û–õ–ì–û–°–†–û–ß–ù–û–ì–û —Ç—Ä–µ–Ω–¥–∞ –¥–ª—è {symbol}:
–¢–ï–•–ù–ò–ß–ï–°–ö–ò–ï –î–ê–ù–ù–´–ï:
- –û—Å–Ω–æ–≤–Ω–æ–π —Ç—Ä–µ–Ω–¥: {trend_info['trend']} (—Å–∏–ª–∞: {trend_info['strength']:.2f})
- –°–∏–ª–∞ —Ç—Ä–µ–Ω–¥–∞ ADX: {trend_info.get('adx', 0):.1f} ({trend_info.get('adx_strength', 'WEAK')})
- –¢–∞–π–º—Ñ—Ä–µ–π–º: {trend_info['timeframe']}
- –¶–µ–Ω–∞ 4h: ${trend_info.get('price_4h', 0):.2f}
- –¶–µ–Ω–∞ 1d: ${trend_info.get('price_1d', 0):.2f}
–°–ò–ì–ù–ê–õ–´ –í–•–û–î–ê:
- –î–µ–π—Å—Ç–≤–∏–µ: {entry_info['action']}
- –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {entry_info['confidence']:.2f}
- RSI: {entry_info.get('rsi', 50):.1f}
- MACD: {entry_info.get('macd', 0):.4f}
- ADX: {entry_info.get('adx', 0):.1f}
–†–ò–°–ö:
- –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å: {risk_info['volatility']}
- –£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞: {risk_info['risk_level']}
- ADX: {risk_info.get('adx', 0):.1f}
–ó–ê–î–ê–ß–ê: –û–ø—Ä–µ–¥–µ–ª–∏ —Ç–æ–ª—å–∫–æ –û–°–ù–û–í–ù–û–ô –¢–†–ï–ù–î (BULLISH/BEARISH/RANGING) –∏ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å 0-1.
–£—á–∏—Ç—ã–≤–∞–π —Å–∏–ª—É —Ç—Ä–µ–Ω–¥–∞ –ø–æ ADX. –ù–µ –¥–∞–≤–∞–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π, —Ç–æ–ª—å–∫–æ —Ç—Ä–µ–Ω–¥.
–û–¢–í–ï–¢ –í –§–û–†–ú–ê–¢–ï JSON: {{"trend": "BULLISH/BEARISH/RANGING", "confidence": 0.XX, "reasoning": "–∫—Ä–∞—Ç–∫–æ–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ"}}
"""
            
            messages = [
                {
                    "role": "system", 
                    "content": "–¢—ã –∞–Ω–∞–ª–∏—Ç–∏–∫. –û–ø—Ä–µ–¥–µ–ª—è–π —Ç–æ–ª—å–∫–æ –î–û–õ–ì–û–°–†–û–ß–ù–´–ô —Ç—Ä–µ–Ω–¥. –£—á–∏—Ç—ã–≤–∞–π ADX –¥–ª—è —Å–∏–ª—ã —Ç—Ä–µ–Ω–¥–∞. –ù–µ –¥–∞–≤–∞–π —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–æ–≤–µ—Ç–æ–≤."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ]
            
            response = self._call_grok_api(messages)
            analysis = self._parse_grok_response(response)
            
            # –û–±–æ–≥–∞—â–∞–µ–º –∞–Ω–∞–ª–∏–∑
            analysis.update({
                'symbol': symbol,
                'timestamp': datetime.now().isoformat(),
                'grok_analysis': True,
                'is_initial_analysis': is_initial
            })
            
            self.cache[cache_key] = analysis
            self.last_analysis_time[symbol] = current_time
            
            # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–µ–≥—É–ª—è—Ä–Ω—ã—Ö –∞–Ω–∞–ª–∏–∑–æ–≤
            if not is_initial:
                self.daily_calls += 1
            
            logger.info(f"üéØ Grok —Ç—Ä–µ–Ω–¥ –¥–ª—è {symbol}: {analysis.get('trend')} (—É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {analysis.get('confidence', 0):.2f}) {'[INITIAL]' if is_initial else ''}")
            
            return analysis
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ Grok —Ç—Ä–µ–Ω–¥–∞: {e}")
            return {'trend': 'NEUTRAL', 'confidence': 0.5, 'reasoning': '–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞', 'grok_analysis': False}
    
    def should_enter_trade(self, primary_trend: str, entry_signal: str, trend_confidence: float) -> bool:
        """–£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏ —Ç—Ä–µ–Ω–¥–∞ –∏ —Å–∏–≥–Ω–∞–ª–∞ –≤—Ö–æ–¥–∞"""
        
        if trend_confidence < 0.5:
            return False
        
        if primary_trend == "RANGING":
            return entry_signal in ["BUY", "SELL"]
        
        if primary_trend == "BULLISH" and entry_signal == "BUY":
            return True
        elif primary_trend == "BEARISH" and entry_signal == "SELL":
            return True
        else:
            return False
    
    def get_daily_stats(self) -> Dict:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é Grok"""
        return {
            'daily_calls': self.daily_calls,
            'max_daily_calls': self.max_daily_calls,
            'remaining_calls': max(0, self.max_daily_calls - self.daily_calls),
            'initial_analysis_done': self.initial_analysis_done,
            'last_reset_day': self.last_reset_day.isoformat()
        }
    
    def _call_grok_api(self, messages: List[Dict]):
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": "grok-3",
            "messages": messages,
            "temperature": 0.3,
            "max_tokens": 150,
            "top_p": 0.9,
            "stream": False
        }
        
        response = requests.post(
            self.endpoint,
            headers=headers,
            json=payload,
            timeout=30
        )
        
        if response.status_code != 200:
            raise Exception(f"–û—à–∏–±–∫–∞ API: {response.status_code} - {response.text}")
        
        return response.json()
    
    def _parse_grok_response(self, response: Dict) -> Dict:
        try:
            content = response['choices'][0]['message']['content'].strip()
            if content.startswith('{') and content.endswith('}'):
                return json.loads(content)
            else:
                match = re.search(r'\{.*\}', content, re.DOTALL)
                if match:
                    return json.loads(match.group(0))
                raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ Grok: {e}")
            return {
                "trend": "NEUTRAL",
                "confidence": 0.5,
                "reasoning": "–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞"
            }

class SocialSentimentGuard:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–µ —Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –∫–∞–∫ –ó–ê–©–ò–¢–ê –æ—Ç —Å–¥–µ–ª–æ–∫"""
    
    def __init__(self):
        self.sentiment_analyzer = FreeSocialSentimentAnalyzer()
        logger.info("Social Sentiment Guard –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def should_avoid_trade(self, symbol: str, analysis: Dict) -> Tuple[bool, str]:
        """–£–ª—É—á—à–µ–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞, —Å–ª–µ–¥—É–µ—Ç –ª–∏ –∏–∑–±–µ–≥–∞—Ç—å —Å–¥–µ–ª–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–æ—Ü.–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π"""
        
        try:
            sentiment_data = self.sentiment_analyzer.get_aggregate_sentiment(symbol)
            action = analysis.get('action')
            primary_trend = analysis.get('primary_trend', {}).get('trend', 'NEUTRAL')
            
            if sentiment_data['confidence'] < 0.2:
                return False, "‚úÖ –°–æ—Ü.–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è —Å–ª–∏—à–∫–æ–º —Å–ª–∞–±—ã –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏"
            
            avoidance_conditions = [
                (sentiment_data['overall_sentiment'] == 'STRONGLY_BEARISH' and action == 'BUY', 
                 "üö´ –°–ò–õ–¨–ù–û –Ω–µ–≥–∞—Ç–∏–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ"),
                
                (sentiment_data['overall_sentiment'] == 'STRONGLY_BULLISH' and action == 'SELL',
                 "üö´ –°–ò–õ–¨–ù–û –ø–æ–∑–∏—Ç–∏–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –ø—Ä–∏ –ø—Ä–æ–¥–∞–∂–µ"),
                
                (sentiment_data['overall_sentiment'] == 'BEARISH' and primary_trend == 'BULLISH' and action == 'BUY' and sentiment_data['confidence'] > 0.5,
                 "‚ö†Ô∏è –°–∏–ª—å–Ω—ã–µ –Ω–µ–≥–∞—Ç–∏–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—Ç —Å –±—ã—á—å–∏–º —Ç—Ä–µ–Ω–¥–æ–º"),
                
                (sentiment_data['overall_sentiment'] == 'BULLISH' and primary_trend == 'BEARISH' and action == 'SELL' and sentiment_data['confidence'] > 0.5,
                 "‚ö†Ô∏è –°–∏–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ç–∏–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –∫–æ–Ω—Ñ–ª–∏–∫—Ç—É—é—Ç —Å –º–µ–¥–≤–µ–∂—å–∏–º —Ç—Ä–µ–Ω–¥–æ–º"),
                
                (sentiment_data['sentiment_score'] < -0.3 and action == 'BUY' and sentiment_data['confidence'] > 0.4,
                 "üö´ –û—á–µ–Ω—å –Ω–∏–∑–∫–∏–π sentiment score –¥–ª—è –ø–æ–∫—É–ø–∫–∏"),
                
                (sentiment_data['sentiment_score'] > 0.3 and action == 'SELL' and sentiment_data['confidence'] > 0.4,
                 "üö´ –û—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π sentiment score –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏")
            ]
            
            for condition, reason in avoidance_conditions:
                if condition:
                    logger.warning(f"–°–æ—Ü.–∑–∞—â–∏—Ç–∞ –¥–ª—è {symbol}: {reason}")
                    return True, reason
            
            if ((sentiment_data['overall_sentiment'] == 'BULLISH' and action == 'BUY') or
                (sentiment_data['overall_sentiment'] == 'BEARISH' and action == 'SELL')):
                analysis['confidence'] = min(analysis['confidence'] * 1.1, 0.95)
                analysis['reasoning'] = analysis.get('reasoning', '') + f" | ‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ —Å–æ—Ü.–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è–º–∏"
            
            return False, "‚úÖ –°–æ—Ü.–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏—è –Ω–µ –±–ª–æ–∫–∏—Ä—É—é—Ç —Å–¥–µ–ª–∫—É"
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ü.–∑–∞—â–∏—Ç—ã: {e}")
            return False, "‚ùå –û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Å–æ—Ü.–Ω–∞—Å—Ç—Ä–æ–µ–Ω–∏–π"

class DynamicPositionManager:
    """–î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏—è–º–∏ –≤–º–µ—Å—Ç–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö TP/SL"""
    
    def __init__(self, trader):
        self.trader = trader
        self.active_managements = {}
        logger.info("Dynamic Position Manager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def manage_position(self, symbol: str, position: Dict, technical_data: Dict):
        """–ê–∫—Ç–∏–≤–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–µ–π"""
        
        try:
            current_price = self.trader.get_ticker(symbol)
            if current_price <= 0:
                return
            
            entry_price = position['entry_price']
            position_side = position['side']
            current_pnl = self.calculate_pnl(position, current_price)
            
            risk_data = technical_data['risk']
            atr = risk_data['atr']
            
            if symbol not in self.active_managements:
                self.active_managements[symbol] = {
                    'entry_price': entry_price,
                    'side': position_side,
                    'highest_pnl': 0,
                    'lowest_pnl': 0,
                    'last_management_time': datetime.now(),
                    'partial_closes': 0
                }
            
            management = self.active_managements[symbol]
            
            if current_pnl > management['highest_pnl']:
                management['highest_pnl'] = current_pnl
            if current_pnl < management['lowest_pnl']:
                management['lowest_pnl'] = current_pnl
            
            dynamic_sl = self.calculate_dynamic_sl(entry_price, atr, position_side)
            
            if current_pnl > 0.02:
                new_sl = self.calculate_trailing_stop(entry_price, current_price, atr, position_side, management['highest_pnl'])
                if self.should_update_sl(position_side, new_sl, current_price):
                    self.update_stop_loss(symbol, new_sl)
                    logger.info(f"üîß –û–±–Ω–æ–≤–ª–µ–Ω SL –¥–ª—è {symbol}: {new_sl:.4f}")
            
            if current_pnl >= 0.05 and management['partial_closes'] == 0:
                self.close_partial_position(symbol, 0.3)
                management['partial_closes'] += 1
                logger.info(f"üéØ –ß–∞—Å—Ç–∏—á–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ {symbol}: 30% @ +5%")
            
            elif current_pnl >= 0.08 and management['partial_closes'] == 1:
                self.close_partial_position(symbol, 0.5)
                management['partial_closes'] += 1
                logger.info(f"üéØ –ß–∞—Å—Ç–∏—á–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ {symbol}: 50% @ +8%")
            
            management['last_management_time'] = datetime.now()
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–µ–π {symbol}: {e}")
    
    def calculate_dynamic_sl(self, entry_price: float, atr: float, side: str) -> float:
        if atr == 0:
            return entry_price * 0.98 if side == 'long' else entry_price * 1.02
        
        if side == 'long':
            return entry_price - (atr * 1.5)
        else:
            return entry_price + (atr * 1.5)
    
    def calculate_trailing_stop(self, entry_price: float, current_price: float, atr: float, side: str, highest_pnl: float) -> float:
        if side == 'long':
            if highest_pnl > 0.02:
                return max(entry_price * 1.005, current_price - (atr * 1.0))
            else:
                return current_price - (atr * 1.5)
        else:
            if highest_pnl > 0.02:
                return min(entry_price * 0.995, current_price + (atr * 1.0))
            else:
                return current_price + (atr * 1.5)
    
    def should_update_sl(self, side: str, new_sl: float, current_price: float) -> bool:
        if side == 'long':
            return new_sl > current_price * 0.995
        else:
            return new_sl < current_price * 1.005
    
    def calculate_pnl(self, position: Dict, current_price: float) -> float:
        entry_price = position['entry_price']
        if position['side'] == 'long':
            return (current_price - entry_price) / entry_price
        else:
            return (entry_price - current_price) / entry_price
    
    def update_stop_loss(self, symbol: str, stop_loss: float):
        try:
            logger.info(f"üîÑ SL –æ–±–Ω–æ–≤–ª–µ–Ω –¥–ª—è {symbol}: {stop_loss:.4f}")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è SL: {e}")
    
    def close_partial_position(self, symbol: str, percentage: float):
        try:
            logger.info(f"üìâ –ß–∞—Å—Ç–∏—á–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ {symbol}: {percentage*100}%")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —á–∞—Å—Ç–∏—á–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è: {e}")

class SmartTradingPipeline:
    """–£–ª—É—á—à–µ–Ω–Ω—ã–π —É–º–Ω—ã–π —Ç–æ—Ä–≥–æ–≤—ã–π –ø–∞–π–ø–ª–∞–π–Ω —Å –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏"""
    
    def __init__(self, trader, technical_analyzer, grok_filter, social_guard, position_manager):
        self.trader = trader
        self.technical_analyzer = technical_analyzer
        self.grok_filter = grok_filter
        self.social_guard = social_guard
        self.position_manager = position_manager
        
        self.daily_trade_count = 0
        self.last_trade_day = datetime.now().date()
        self.max_daily_trades = 5
        self.executed_trades = []
        self.symbol_trade_count = {}
        self.initial_grok_analysis = {}
        
        logger.info("üéØ Smart Trading Pipeline –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def set_initial_grok_analysis(self, initial_analysis: Dict):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã—Ö –∞–Ω–∞–ª–∏–∑–æ–≤ Grok"""
        self.initial_grok_analysis = initial_analysis
        logger.info(f"üéØ –ó–∞–≥—Ä—É–∂–µ–Ω–æ {len(initial_analysis)} –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã—Ö –∞–Ω–∞–ª–∏–∑–æ–≤ Grok")
    
    def process_trade_decision(self, symbol: str) -> Dict:
        """–£–ª—É—á—à–µ–Ω–Ω—ã–π –ø–∞–π–ø–ª–∞–π–Ω –ø—Ä–∏–Ω—è—Ç–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Ä–µ—à–µ–Ω–∏–π —Å –¥–µ—Ç–∞–ª—å–Ω–æ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–æ–π"""
        
        try:
            if not self.can_trade_today(symbol):
                return {'action': 'HOLD', 'reason': '–î–Ω–µ–≤–Ω–æ–π –ª–∏–º–∏—Ç —Å–¥–µ–ª–æ–∫ –∏—Å—á–µ—Ä–ø–∞–Ω', 'confidence': 0}
            
            technical_data = self.technical_analyzer.get_multi_timeframe_analysis(symbol, self.trader.exchange)
            
            # üîç –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê - –î–û–ë–ê–í–õ–ï–ù–û
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ Grok –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–µ–Ω
            if symbol in self.initial_grok_analysis:
                primary_trend = self.initial_grok_analysis[symbol]
                logger.info(f"üéØ {symbol} - –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—á–∞–ª—å–Ω—ã–π Grok: {primary_trend.get('trend')} ({primary_trend.get('confidence', 0):.2f})")
            else:
                primary_trend = self.grok_filter.analyze_primary_trend(symbol, technical_data)
                logger.info(f"üéØ {symbol} - –ù–æ–≤—ã–π Grok –∞–Ω–∞–ª–∏–∑: {primary_trend.get('trend')} ({primary_trend.get('confidence', 0):.2f})")
            
            entry_signal = technical_data['entry']
            logger.info(f"üîß {symbol} - –¢–µ—Ö.—Å–∏–≥–Ω–∞–ª: {entry_signal['action']} (conf: {entry_signal['confidence']:.2f})")
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç–∏
            should_enter = self.grok_filter.should_enter_trade(
                primary_trend['trend'], 
                entry_signal['action'],
                primary_trend['confidence']
            )
            logger.info(f"ü§ù {symbol} - –°–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å: {should_enter}")
            
            if not should_enter:
                logger.info(f"üö´ {symbol} - –ü–†–ò–ß–ò–ù–ê HOLD: –ù–µ—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å —Ç—Ä–µ–Ω–¥–∞ {primary_trend['trend']} vs —Å–∏–≥–Ω–∞–ª–∞ {entry_signal['action']}")
                return {
                    'action': 'HOLD', 
                    'reason': f"–ù–µ—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω–æ—Å—Ç—å: —Ç—Ä–µ–Ω–¥ {primary_trend['trend']} vs —Å–∏–≥–Ω–∞–ª {entry_signal['action']}",
                    'confidence': entry_signal['confidence']  # üîç –î–û–ë–ê–í–õ–ï–ù–û confidence –¥–ª—è –¥–∞—à–±–æ—Ä–¥–∞
                }
            
            analysis_for_social = {
                'action': entry_signal['action'],
                'primary_trend': primary_trend,
                'confidence': entry_signal['confidence']
            }
            
            should_avoid, social_reason = self.social_guard.should_avoid_trade(symbol, analysis_for_social)
            if should_avoid:
                return {'action': 'HOLD', 'reason': social_reason, 'confidence': entry_signal['confidence']}
            
            execution_data = technical_data['execution']
            if execution_data['optimal_entry'] is None or execution_data['confidence'] < 0.4:
                return {'action': 'HOLD', 'reason': '–°–ª–∞–±—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ –≤—Ö–æ–¥–∞', 'confidence': entry_signal['confidence']}
            
            if not self.passes_quality_checks(symbol, technical_data, primary_trend, entry_signal):
                return {'action': 'HOLD', 'reason': '–ù–µ –ø—Ä–æ–π–¥–µ–Ω—ã –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞', 'confidence': entry_signal['confidence']}
            
            trade_result = self.execute_trade(symbol, technical_data, primary_trend, entry_signal)
            
            if trade_result['executed']:
                self.record_trade_execution(symbol)
                return {'action': 'EXECUTED', 'trade': trade_result, 'confidence': entry_signal['confidence']}
            else:
                # üîç –î–ï–¢–ê–õ–¨–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –û–®–ò–ë–ö–ò –ò–°–ü–û–õ–ù–ï–ù–ò–Ø - –î–û–ë–ê–í–õ–ï–ù–û
                logger.error(f"‚ùå {symbol} - –û—à–∏–±–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è: {trade_result.get('reason', 'Unknown error')}")
                return {'action': 'HOLD', 'reason': f"–û—à–∏–±–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è: {trade_result.get('reason', 'Unknown error')}", 'confidence': entry_signal['confidence']}
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –ø–∞–π–ø–ª–∞–π–Ω–∞ {symbol}: {e}")
            return {'action': 'HOLD', 'reason': f'–û—à–∏–±–∫–∞ –ø–∞–π–ø–ª–∞–π–Ω–∞: {str(e)}', 'confidence': 0}
    
    def can_trade_today(self, symbol: str) -> bool:
        today = datetime.now().date()
        if today != self.last_trade_day:
            self.daily_trade_count = 0
            self.symbol_trade_count = {}
            self.last_trade_day = today
        
        symbol_count = self.symbol_trade_count.get(symbol, 0)
        can_trade = self.daily_trade_count < self.max_daily_trades and symbol_count < 2
        
        if not can_trade:
            logger.warning(f"üö´ –î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç —Å–¥–µ–ª–æ–∫: –æ–±—â–∏–µ {self.daily_trade_count}/{self.max_daily_trades}, {symbol}: {symbol_count}/2")
        
        return can_trade
    
    def passes_quality_checks(self, symbol: str, technical_data: Dict, primary_trend: Dict, entry_signal: Dict) -> bool:
        # üîç –î–ï–¢–ê–õ–¨–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –ü–†–û–í–ï–†–û–ö –ö–ê–ß–ï–°–¢–í–ê - –î–û–ë–ê–í–õ–ï–ù–û
        checks = []
        
        # 1. Confidence check
        conf_check = entry_signal['confidence'] >= 0.4
        checks.append(f"Confidence: {entry_signal['confidence']:.2f} >= 0.4 = {conf_check}")
        
        # 2. Trend confidence
        trend_check = primary_trend['confidence'] >= 0.4
        checks.append(f"Trend confidence: {primary_trend['confidence']:.2f} >= 0.4 = {trend_check}")
        
        # 3. Volatility check
        vol_check = technical_data['risk']['volatility'] != 'HIGH' or entry_signal['confidence'] > 0.6
        checks.append(f"Volatility: {technical_data['risk']['volatility']} check = {vol_check}")
        
        # 4. RSI check
        rsi = entry_signal.get('rsi', 50)
        rsi_check = 15 <= rsi <= 85
        checks.append(f"RSI: {rsi:.1f} in [15,85] = {rsi_check}")
        
        # 5. Execution confidence
        exec_check = technical_data['execution']['confidence'] >= 0.3
        checks.append(f"Execution: {technical_data['execution']['confidence']:.2f} >= 0.3 = {exec_check}")
        
        # 6. ADX check
        adx = technical_data['trend'].get('adx', 0)
        adx_check = adx > 10 or entry_signal['confidence'] > 0.6
        checks.append(f"ADX: {adx:.1f} > 10 = {adx_check}")
        
        score = sum([conf_check, trend_check, vol_check, rsi_check, exec_check, adx_check])
        passes = score >= 4
        
        logger.info(f"üìã {symbol} - Quality checks: {score}/6")
        for check in checks:
            logger.info(f"   üìù {check}")
        logger.info(f"   ‚úÖ Final quality: {passes}")
        
        return passes
    
    def execute_trade(self, symbol: str, technical_data: Dict, primary_trend: Dict, entry_signal: Dict) -> Dict:
        try:
            execution_data = technical_data['execution']
            risk_data = technical_data['risk']
            
            position_size_percent = self.calculate_position_size(
                entry_signal['confidence'], 
                risk_data['volatility'],
                risk_data.get('position_size_multiplier', 1.0)
            )
            
            current_price = execution_data['current_price']
            atr = risk_data['atr']
            
            if entry_signal['action'] == 'BUY':
                stop_loss = current_price - (atr * risk_data['recommended_sl_multiplier'])
                take_profit = current_price + (atr * 2.5)
                side = 'buy'
            else:
                stop_loss = current_price + (atr * risk_data['recommended_sl_multiplier'])
                take_profit = current_price - (atr * 2.5)
                side = 'sell'
            
            account_info = self.trader.get_account_info()
            position_size_usdt = account_info['available_balance'] * position_size_percent / 100
            
            # üîç –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –†–ê–°–ß–ï–¢–ê –†–ê–ó–ú–ï–†–ê –ü–û–ó–ò–¶–ò–ò - –î–û–ë–ê–í–õ–ï–ù–û
            logger.info(f"üí∞ {symbol} - –†–∞—Å—á–µ—Ç –ø–æ–∑–∏—Ü–∏–∏:")
            logger.info(f"   –ë–∞–ª–∞–Ω—Å: {account_info['available_balance']:.2f} USDT")
            logger.info(f"   –†–∞–∑–º–µ—Ä: {position_size_percent:.1f}% = {position_size_usdt:.2f} USDT")
            logger.info(f"   –¶–µ–Ω–∞: {current_price:.4f}")
            logger.info(f"   –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {position_size_usdt / current_price:.4f}")
            
            if position_size_usdt < 10:
                logger.warning(f"üí∞ {symbol} - –°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏: {position_size_usdt:.2f} USDT")
                return {'executed': False, 'reason': '–°–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–∏–π —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏'}
            
            position_size = position_size_usdt / current_price
            
            # üîç –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê –ü–ê–†–ê–ú–ï–¢–†–û–í –û–†–î–ï–†–ê - –î–û–ë–ê–í–õ–ï–ù–û
            logger.info(f"üìä {symbol} - –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ä–¥–µ—Ä–∞:")
            logger.info(f"   –°—Ç–æ—Ä–æ–Ω–∞: {side}")
            logger.info(f"   –†–∞–∑–º–µ—Ä: {position_size:.4f}")
            logger.info(f"   –¶–µ–Ω–∞: {current_price:.4f}")
            logger.info(f"   SL: {stop_loss:.4f}")
            logger.info(f"   TP: {take_profit:.4f}")
            
            order = self.trader.create_order(
                symbol, 'market', side, position_size,
                take_profit=take_profit,
                stop_loss=stop_loss
            )
            
            if order:
                trade_info = {
                    'symbol': symbol,
                    'side': side,
                    'size': position_size,
                    'entry_price': current_price,
                    'stop_loss': stop_loss,
                    'take_profit': take_profit,
                    'timestamp': datetime.now().isoformat(),
                    'confidence': entry_signal['confidence'],
                    'trend': primary_trend['trend'],
                    'position_size_percent': position_size_percent,
                    'position_size_usdt': position_size_usdt
                }
                
                self.executed_trades.append(trade_info)
                logger.info(f"‚úÖ –°–î–ï–õ–ö–ê –ò–°–ü–û–õ–ù–ï–ù–ê: {side} {symbol} @ {current_price:.4f}, —Ä–∞–∑–º–µ—Ä: {position_size_percent:.1f}%")
                
                return {
                    'executed': True,
                    'trade': trade_info,
                    'position_size_usdt': position_size_usdt
                }
            else:
                logger.error(f"‚ùå {symbol} - –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ä–¥–µ—Ä–∞")
                return {'executed': False, 'reason': '–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –æ—Ä–¥–µ—Ä–∞'}
            
        except Exception as e:
            logger.error(f"‚ùå {symbol} - –û—à–∏–±–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏: {e}")
            return {'executed': False, 'reason': f'–û—à–∏–±–∫–∞ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è: {str(e)}'}
    
    def calculate_position_size(self, confidence: float, volatility: str, adx_multiplier: float) -> float:
        base_size = 15
        
        confidence_multiplier = min(confidence / 0.7, 1.2)
        
        if volatility == 'HIGH':
            volatility_multiplier = 0.7
        elif volatility == 'MEDIUM':
            volatility_multiplier = 0.9
        else:
            volatility_multiplier = 1.1
        
        final_size = base_size * confidence_multiplier * volatility_multiplier * adx_multiplier
        return min(final_size, 20)
    
    def record_trade_execution(self, symbol: str):
        self.daily_trade_count += 1
        self.symbol_trade_count[symbol] = self.symbol_trade_count.get(symbol, 0) + 1
        logger.info(f"üìä –°–¥–µ–ª–∫–∞ –∑–∞–ø–∏—Å–∞–Ω–∞. –°–µ–≥–æ–¥–Ω—è: {self.daily_trade_count}/{self.max_daily_trades}, {symbol}: {self.symbol_trade_count[symbol]}/2")
    
    def get_pipeline_stats(self) -> Dict:
        return {
            'daily_trades': f"{self.daily_trade_count}/{self.max_daily_trades}",
            'total_executed_trades': len(self.executed_trades),
            'symbol_trades': self.symbol_trade_count,
            'last_trade_day': self.last_trade_day.isoformat(),
            'initial_grok_analysis_count': len(self.initial_grok_analysis)
        }

class KnowledgeBase:
    def __init__(self, file_path: str = 'knowledge_base.json'):
        self.file_path = file_path
        self.analysis_history = []
        self.lock = threading.Lock()
        self._last_save = datetime.now()
        self.load_from_file()
    
    def record_analysis(self, symbol: str, analysis: Dict, account_info: Dict):
        """üîß –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –ó–ê–ü–ò–°–¨ –° –û–ì–†–ê–ù–ò–ß–ï–ù–ò–ï–ú –†–ê–ó–ú–ï–†–ê"""
        with self.lock:
            entry = {
                'timestamp': datetime.now().isoformat(),
                'symbol': symbol,
                'analysis': analysis,
                'account_info': account_info
            }
            
            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä –∏—Å—Ç–æ—Ä–∏–∏
            if len(self.analysis_history) >= 1000:
                self.analysis_history = self.analysis_history[-500:]
                logger.info("üßπ –°–æ–∫—Ä–∞—â–µ–Ω–∞ –∏—Å—Ç–æ—Ä–∏—è –∞–Ω–∞–ª–∏–∑–∞ –¥–æ 500 –∑–∞–ø–∏—Å–µ–π")
            
            self.analysis_history.append(entry)
            
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–∞ –¥–∏—Å–∫ —Ç–æ–ª—å–∫–æ –∫–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
            if (datetime.now() - self._last_save) > timedelta(minutes=10):
                self.save_to_file()
                self._last_save = datetime.now()

    def save_to_file(self):
        """üîß –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï –°–û–•–†–ê–ù–ï–ù–ò–ï"""
        try:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 200 –∑–∞–ø–∏—Å–µ–π
            data = {
                'analysis_history': self.analysis_history[-200:],
                'last_updated': datetime.now().isoformat()
            }
            
            with open(self.file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è Knowledge Base: {e}")

    def load_from_file(self):
        try:
            if not os.path.exists(self.file_path):
                return
            with open(self.file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.analysis_history = data.get('analysis_history', [])
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Knowledge Base: {e}")
            self.analysis_history = []
    
    def get_recent_analysis(self, limit: int = 10):
        return self.analysis_history[-limit:]

class TradingScheduler:
    def __init__(self, trading_pipeline, trader, knowledge_base):
        self.trading_pipeline = trading_pipeline
        self.trader = trader
        self.knowledge = knowledge_base
        self.symbols = []
        self.is_running = False
        self.analysis_count = 0
        self.analysis_interval = 30
        self._last_memory_check = datetime.now()
        logger.info("Trading Scheduler –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
    
    def _check_memory_usage(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏"""
        if (datetime.now() - self._last_memory_check) > timedelta(hours=2):
            logger.info("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –ø–∞–º—è—Ç–∏...")
            
            # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π —Å–±–æ—Ä –º—É—Å–æ—Ä–∞
            collected = gc.collect()
            logger.info(f"üßπ –°–±–æ—Ä—â–∏–∫ –º—É—Å–æ—Ä–∞ –æ—Å–≤–æ–±–æ–¥–∏–ª {collected} –æ–±—ä–µ–∫—Ç–æ–≤")
            
            self._last_memory_check = datetime.now()

    def setup(self, symbols: list, leverage: int, max_position_size: int):
        working_symbols = []
        for symbol in symbols:
            try:
                price = self.trader.get_ticker(symbol)
                if price > 0:
                    working_symbols.append(symbol)
                    self.trader.set_leverage(symbol, leverage)
                    logger.info(f"–°–∏–º–≤–æ–ª {symbol} —Ä–∞–±–æ—Ç–∞–µ—Ç, —Ü–µ–Ω–∞: {price}")
            except Exception as e:
                logger.warning(f"–°–∏–º–≤–æ–ª {symbol} –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç: {e}")
        
        self.symbols = working_symbols
        logger.info(f"–ù–∞—Å—Ç—Ä–æ–µ–Ω–æ {len(self.symbols)} —Ä–∞–±–æ—á–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤")
    
    def run_market_analysis(self):
        try:
            self._check_memory_usage()
            self.analysis_count += 1
            
            # üîß –û–ì–†–ê–ù–ò–ß–ò–í–ê–ï–ú –°–ß–ï–¢–ß–ò–ö –ê–ù–ê–õ–ò–ó–ê –î–õ–Ø –ü–†–ï–î–û–¢–í–†–ê–©–ï–ù–ò–Ø –ü–ï–†–ï–ü–û–õ–ù–ï–ù–ò–Ø
            if self.analysis_count > 1000000:
                self.analysis_count = 1
                logger.info("üîÑ –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –∞–Ω–∞–ª–∏–∑–∞")
            
            logger.info(f"üîç –ó–ê–ü–£–°–ö –ê–ù–ê–õ–ò–ó–ê #{self.analysis_count} - {datetime.now().strftime('%H:%M:%S')}")
            
            account_info = self.trader.get_account_info()
            logger.info(f"–ë–∞–ª–∞–Ω—Å: {account_info['total_balance']:.2f} USDT, –î–æ—Å—Ç—É–ø–Ω–æ: {account_info['available_balance']:.2f} USDT")
            
            pipeline_stats = self.trading_pipeline.get_pipeline_stats()
            logger.info(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ø–∞–π–ø–ª–∞–π–Ω–∞: {pipeline_stats['daily_trades']}")
            
            for symbol in self.symbols:
                try:
                    logger.info(f"–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º {symbol}...")
                    
                    decision = self.trading_pipeline.process_trade_decision(symbol)
                    logger.info(f"–†–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è {symbol}: {decision.get('action')}")
                    
                    self.knowledge.record_analysis(symbol, decision, account_info)
                    
                    time.sleep(2)  # –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–∏–º–≤–æ–ª–∞–º–∏
                    
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ {symbol}: {e}")
                    continue  # üîß –ü–†–û–î–û–õ–ñ–ê–ï–ú –†–ê–ë–û–¢–£ –ü–†–ò –û–®–ò–ë–ö–ê–• –û–¢–î–ï–õ–¨–ù–´–• –°–ò–ú–í–û–õ–û–í
            
            logger.info(f"‚úÖ –ê–ù–ê–õ–ò–ó #{self.analysis_count} –ó–ê–í–ï–†–®–ï–ù")
                    
        except Exception as e:
            logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ —Ä—ã–Ω–∫–∞: {e}")
            # üîß –ù–ï –ü–ê–î–ê–ï–ú –ü–û–õ–ù–û–°–¢–¨–Æ –ü–†–ò –û–®–ò–ë–ö–ê–•

    def start(self):
        self.is_running = True
        logger.info(f"üîÑ –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–ø—É—â–µ–Ω - –∞–Ω–∞–ª–∏–∑ –∫–∞–∂–¥—ã–µ {self.analysis_interval} –º–∏–Ω—É—Ç")
        
        while self.is_running:
            try:
                self.run_market_analysis()
                logger.info(f"‚è∞ –û–∂–∏–¥–∞–Ω–∏–µ {self.analysis_interval} –º–∏–Ω—É—Ç –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞...")
                
                # üîß –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï –û–ñ–ò–î–ê–ù–ò–ï –° –ü–†–û–í–ï–†–ö–û–ô –û–°–¢–ê–ù–û–í–ö–ò
                wait_seconds = self.analysis_interval * 60
                for i in range(wait_seconds):
                    if not self.is_running:
                        break
                    if i % 60 == 0:  # –õ–æ–≥–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
                        minutes_left = (wait_seconds - i) // 60
                        logger.debug(f"‚è≥ –î–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞: {minutes_left} –º–∏–Ω")
                    time.sleep(1)
                    
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ: {e}")
                time.sleep(60)  # üîß –ö–û–†–û–¢–ö–ê–Ø –ü–ê–£–ó–ê –ü–†–ò –û–®–ò–ë–ö–ê–•

    def stop(self):
        self.is_running = False
        logger.info("üõë –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

# üîß –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–ò –°–ï–ê–ù–°–ê
def init_session_state():
    """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ–∞–Ω—Å–∞ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç —Ä–µ–∫—É—Ä—Å–∏–∏"""
    required_keys = {
        'bot_started': False,
        'trader': None,
        'scheduler': None,
        'grok_status': "–ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω",
        'last_update': None,
        'scheduler_running': False,
        'initial_grok_analysis': {},
        'session_start_time': datetime.now().isoformat(),
        'refresh_count': 0
    }
    
    for key, default_value in required_keys.items():
        if key not in st.session_state:
            st.session_state[key] = default_value

# üîß –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –ì–õ–ê–í–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –° –ó–ê–©–ò–¢–û–ô –û–¢ –†–ï–ö–£–†–°–ò–ò
def main():
    st.set_page_config(
        page_title="Grok Smart Trading Bot v2.4", 
        layout="wide", 
        page_icon="ü§ñ",
        initial_sidebar_state="expanded"
    )
    
    init_session_state()
    
    # üîß –°–ß–ï–¢–ß–ò–ö –û–ë–ù–û–í–õ–ï–ù–ò–ô –î–õ–Ø –ü–†–ï–î–û–¢–í–†–ê–©–ï–ù–ò–Ø –†–ï–ö–£–†–°–ò–ò
    st.session_state.refresh_count += 1
    if st.session_state.refresh_count > 1000:
        st.session_state.refresh_count = 1
        logger.info("üîÑ –°–±—Ä–æ—Å —Å—á–µ—Ç—á–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞")
    
    st.title("ü§ñ Grok Smart Trading Bot v2.4")
    st.markdown("### –°—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º —Ä–µ–∫—É—Ä—Å–∏–∏")
    
    # üîß –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –°–ê–ô–î–ë–ê–†
    with st.sidebar:
        st.header("üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –¢–æ—Ä–≥–æ–≤–ª–∏")
        
        st.subheader("‚öôÔ∏è –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¢–æ—Ä–≥–æ–≤–ª–∏")
        
        top_symbols = [
            'BTC/USDT:USDT', 'ETH/USDT:USDT', 'SOL/USDT:USDT', 'BNB/USDT:USDT',
            'XRP/USDT:USDT', 'ADA/USDT:USDT', 'AVAX/USDT:USDT', 'DOGE/USDT:USDT',
            'DOT/USDT:USDT', 'LINK/USDT:USDT'
        ]
        
        selected_symbols = st.multiselect(
            "–¢–æ—Ä–≥—É–µ–º—ã–µ —Ñ—å—é—á–µ—Ä—Å—ã (–º–∞–∫—Å 8):", 
            top_symbols, 
            default=['BTC/USDT:USDT', 'ETH/USDT:USDT', 'SOL/USDT:USDT', 'BNB/USDT:USDT'],
            max_selections=8
        )
        
        leverage = st.slider("–ü–ª–µ—á–æ:", 1, 10, 5)
        position_size = st.slider("–†–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏ (%):", 5, 30, 15)
        
        st.subheader("üóÉÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã–º–∏")
        if st.button("üßπ –û—á–∏—Å—Ç–∏—Ç—å Knowledge Base", type="secondary"):
            if os.path.exists('knowledge_base.json'):
                os.remove('knowledge_base.json')
                st.success("‚úÖ Knowledge Base –æ—á–∏—â–µ–Ω–∞!")
            else:
                st.info("üìÅ Knowledge Base –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        
        st.subheader("üöÄ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ")
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("üöÄ –ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞", type="primary", use_container_width=True):
                if not selected_symbols:
                    st.error("‚ùå –í—ã–±–µ—Ä–∏—Ç–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏!")
                else:
                    start_trading_bot(selected_symbols, leverage, position_size)
        
        with col2:
            if st.button("üõë –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–æ—Ç–∞", use_container_width=True):
                stop_trading_bot()
        
        # üîß –ò–ù–§–û–†–ú–ê–¶–ò–Ø –û –°–ï–ê–ù–°–ï
        st.divider()
        if st.session_state.bot_started:
            session_time = datetime.now() - datetime.fromisoformat(st.session_state.session_start_time)
            st.info(f"**–°–µ–∞–Ω—Å:** {str(session_time).split('.')[0]}")
            st.info(f"**–û–±–Ω–æ–≤–ª–µ–Ω–∏–π:** {st.session_state.refresh_count}")

    if st.session_state.bot_started:
        display_trading_dashboard()
    else:
        display_welcome_screen()
    
    # üîß –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï –û–ë–ù–û–í–õ–ï–ù–ò–ï –ò–ù–¢–ï–†–§–ï–ô–°–ê
    if st.session_state.bot_started and st.session_state.scheduler_running:
        # –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥ –≤–º–µ—Å—Ç–æ 10
        time.sleep(15)
        st.rerun()

def display_welcome_screen():
    st.info("üëÜ –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏")
    
    with st.expander("üîç –°—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è v2.4", expanded=True):
        st.markdown("""
        ### üéØ –ö–õ–Æ–ß–ï–í–´–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–Ø:
        **üîß –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–∫—É—Ä—Å–∏–∏:**
        - –£–≤–µ–ª–∏—á–µ–Ω –ª–∏–º–∏—Ç —Ä–µ–∫—É—Ä—Å–∏–∏ –¥–æ 2000
        - –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –≤—ã–∑–æ–≤—ã Streamlit
        - –†–µ–≥—É–ª—è—Ä–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∫—ç—à–µ–π
        **üßπ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é:**
        - –ê–≤—Ç–æ–æ—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        - –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –∏—Å—Ç–æ—Ä–∏–∏
        - –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π —Å–±–æ—Ä –º—É—Å–æ—Ä–∞
        **‚ö° –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:**
        - –£–≤–µ–ª–∏—á–µ–Ω –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–æ 15 —Å–µ–∫—É–Ω–¥
        - –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –¥–∞—à–±–æ—Ä–¥
        - –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–º–≤–æ–ª–æ–≤
        **üéØ –°—Ç–∞–±–∏–ª—å–Ω–∞—è —Ä–∞–±–æ—Ç–∞:**
        - –ó–∞—â–∏—Ç–∞ –æ—Ç –æ—à–∏–±–æ–∫ –æ—Ç–¥–µ–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
        - –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã –ø—Ä–∏ —á–∞—Å—Ç–∏—á–Ω—ã—Ö —Å–±–æ—è—Ö
        - –ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–π
        """)

def start_trading_bot(symbols, leverage, position_size):
    try:
        if st.session_state.scheduler_running:
            st.warning("–ë–æ—Ç —É–∂–µ –∑–∞–ø—É—â–µ–Ω!")
            return True
        
        st.info("üîÑ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –°–¢–ê–ë–ò–õ–¨–ù–û–ì–û —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞ v2.4...")
        
        # –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–∞–ø—É—Å–∫–∞
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        status_text.text("–®–∞–≥ 1/4: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤...")
        progress_bar.progress(25)
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –≤—à–∏—Ç—ã–µ –∫–ª—é—á–∏
        bybit_api_key = "OqFgjGKhzUyTU2Yesq"
        bybit_secret = "UazxgpqNbiFCFApiOHAd1f1s57a2GhXc4w7x"
        grok_api_key = "xai-p4j0VXesw69krSosEru3vufOu8XQkpYpMU7MBxQi9BGMFn6jq5QmAhjwsmcRD2CcEtfhvG28os6Ld822"
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
        trader = BybitFuturesTrader(bybit_api_key, bybit_secret, False)
        technical_analyzer = AdvancedTechnicalAnalyzer()
        grok_filter = GrokTrendFilter(grok_api_key)
        social_guard = SocialSentimentGuard()
        position_manager = DynamicPositionManager(trader)
        
        status_text.text("–®–∞–≥ 2/4: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–∏–º–≤–æ–ª–æ–≤ –∏ –ø–ª–µ—á–∞...")
        progress_bar.progress(50)
        
        # –°–æ–∑–¥–∞–Ω–∏–µ —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –ø–∞–π–ø–ª–∞–π–Ω–∞
        trading_pipeline = SmartTradingPipeline(
            trader, technical_analyzer, grok_filter, social_guard, position_manager
        )
        
        knowledge = KnowledgeBase()
        knowledge.load_from_file()
        
        status_text.text("–®–∞–≥ 3/4: –ó–∞–ø—É—Å–∫ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ Grok...")
        progress_bar.progress(75)
        
        # –í–´–ü–û–õ–ù–Ø–ï–ú –ú–ì–ù–û–í–ï–ù–ù–´–ô –ê–ù–ê–õ–ò–ó GROK –ü–†–ò –ó–ê–ü–£–°–ö–ï
        initial_grok_analysis = grok_filter.perform_initial_analysis(symbols, technical_analyzer, trader.exchange)
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
        trading_pipeline.set_initial_grok_analysis(initial_grok_analysis)
        st.session_state.initial_grok_analysis = initial_grok_analysis
        
        status_text.text("–®–∞–≥ 4/4: –ó–∞–ø—É—Å–∫ –ø–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫–∞...")
        progress_bar.progress(100)
        
        scheduler = TradingScheduler(trading_pipeline, trader, knowledge)
        scheduler.setup(symbols, leverage, position_size)
        
        if not scheduler.symbols:
            st.error("‚ùå –ù–µ—Ç —Ä–∞–±–æ—á–∏—Ö —Å–∏–º–≤–æ–ª–æ–≤!")
            return False
        
        st.session_state.trader = trader
        st.session_state.scheduler = scheduler
        st.session_state.trading_pipeline = trading_pipeline
        st.session_state.grok_filter = grok_filter
        
        def run_scheduler():
            scheduler.start()
        
        scheduler_thread = threading.Thread(target=run_scheduler)
        scheduler_thread.daemon = True
        scheduler_thread.start()
        
        st.session_state.bot_started = True
        st.session_state.scheduler_running = True
        
        # –û—á–∏—â–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
        progress_bar.empty()
        status_text.empty()
        
        st.success("‚úÖ –°–¢–ê–ë–ò–õ–¨–ù–´–ô –±–æ—Ç v2.4 –∑–∞–ø—É—â–µ–Ω!")
        
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
        if initial_grok_analysis:
            st.subheader("üéØ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–≥–Ω–æ–≤–µ–Ω–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ Grok:")
            for symbol, analysis in initial_grok_analysis.items():
                trend = analysis.get('trend', 'NEUTRAL')
                confidence = analysis.get('confidence', 0) * 100
                reasoning = analysis.get('reasoning', '')[:100] + "..." if len(analysis.get('reasoning', '')) > 100 else analysis.get('reasoning', '')
                
                if trend == 'BULLISH':
                    st.success(f"**{symbol}**: üü¢ {trend} ({confidence:.1f}%) - {reasoning}")
                elif trend == 'BEARISH':
                    st.error(f"**{symbol}**: üî¥ {trend} ({confidence:.1f}%) - {reasoning}")
                else:
                    st.info(f"**{symbol}**: ‚ö™ {trend} ({confidence:.1f}%) - {reasoning}")
        
        return True
        
    except Exception as e:
        st.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞: {str(e)}")
        return False

def stop_trading_bot():
    if st.session_state.scheduler:
        st.session_state.scheduler.stop()
        st.session_state.trader = None
        st.session_state.scheduler = None
        st.session_state.scheduler_running = False
        st.session_state.initial_grok_analysis = {}
        st.success("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        st.session_state.bot_started = False
    else:
        st.warning("‚ö†Ô∏è –ë–æ—Ç –Ω–µ –∑–∞–ø—É—â–µ–Ω")

# üîß –û–ë–ù–û–í–õ–ï–ù–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –î–ê–®–ë–û–†–î–ê
def display_trading_dashboard():
    """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –¥–∞—à–±–æ—Ä–¥ —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –æ—à–∏–±–æ–∫"""
    
    st.header("üìä –î–∞—à–±–æ—Ä–¥ –°—Ç–∞–±–∏–ª—å–Ω–æ–≥–æ –¢–æ—Ä–≥–æ–≤–æ–≥–æ –ë–æ—Ç–∞ v2.4")
    
    try:
        st.session_state.last_update = datetime.now().strftime("%H:%M:%S")
        
        if st.session_state.trader:
            # üîß –ó–ê–©–ò–©–ï–ù–ù–´–ô –ü–û–õ–£–ß–ï–ù–ò–ï –ò–ù–§–û–†–ú–ê–¶–ò–ò –û –°–ß–ï–¢–ï
            try:
                account_info = st.session_state.trader.get_account_info()
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å—á–µ—Ç–µ: {e}")
                account_info = {
                    'total_balance': 0.0, 'available_balance': 0.0, 'margin_used': 0.0,
                    'positions_count': 0, 'orders_count': 0, 'unrealized_pnl': 0.0
                }
            
            col1, col2, col3, col4, col5 = st.columns(5)
            with col1:
                st.metric("–û–±—â–∏–π –±–∞–ª–∞–Ω—Å", f"{account_info['total_balance']:.2f} USDT")
            with col2:
                st.metric("–î–æ—Å—Ç—É–ø–Ω–æ", f"{account_info['available_balance']:.2f} USDT")
            with col3:
                st.metric("P&L", f"{account_info['unrealized_pnl']:.2f} USDT")
            with col4:
                st.metric("–ü–æ–∑–∏—Ü–∏–∏", account_info['positions_count'])
            with col5:
                st.metric("–û—Ä–¥–µ—Ä–∞", account_info['orders_count'])
            
            # üîß –ó–ê–©–ò–©–ï–ù–ù–û–ï –û–¢–û–ë–†–ê–ñ–ï–ù–ò–ï –°–¢–ê–¢–ò–°–¢–ò–ö–ò
            if st.session_state.trading_pipeline:
                try:
                    pipeline_stats = st.session_state.trading_pipeline.get_pipeline_stats()
                    
                    col1, col2, col3, col4 = st.columns(4)
                    with col1:
                        st.metric("–°–¥–µ–ª–æ–∫ —Å–µ–≥–æ–¥–Ω—è", pipeline_stats['daily_trades'])
                    with col2:
                        st.metric("–í—Å–µ–≥–æ —Å–¥–µ–ª–æ–∫", pipeline_stats['total_executed_trades'])
                    with col3:
                        st.metric("–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞", "v2.4 –°–¢–ê–ë–ò–õ–¨–ù–ê–Ø")
                    with col4:
                        st.metric("–°–ª–µ–¥—É—é—â–∏–π –∞–Ω–∞–ª–∏–∑", "30 –º–∏–Ω")
                except Exception as e:
                    st.error(f"–û—à–∏–±–∫–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")
            
            # üîß –£–ü–†–û–©–ï–ù–ù–ê–Ø –ò–°–¢–û–†–ò–Ø –†–ï–®–ï–ù–ò–ô
            if st.session_state.scheduler:
                try:
                    st.subheader("üìù –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ—à–µ–Ω–∏—è")
                    recent = st.session_state.scheduler.knowledge.get_recent_analysis(limit=5)
                    if recent:
                        simplified_data = []
                        for r in recent:
                            simplified_data.append({
                                '–í—Ä–µ–º—è': r['timestamp'][11:16],
                                '–°–∏–º–≤–æ–ª': r['symbol'],
                                '–†–µ—à–µ–Ω–∏–µ': r['analysis'].get('action', 'N/A'),
                                '–ü—Ä–∏—á–∏–Ω–∞': (r['analysis'].get('reason', 'N/A')[:40] + '...') if len(r['analysis'].get('reason', '')) > 40 else r['analysis'].get('reason', 'N/A')
                            })
                        st.dataframe(pd.DataFrame(simplified_data), use_container_width=True)
                    else:
                        st.info("–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞")
                except Exception as e:
                    st.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Ä–µ—à–µ–Ω–∏–π")
            
            st.info(f"üïí –û–±–Ω–æ–≤–ª–µ–Ω–æ: {st.session_state.last_update} | üîÑ {st.session_state.refresh_count}")
            
    except Exception as e:
        logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –¥–∞—à–±–æ—Ä–¥–∞: {e}")
        st.error("‚ö†Ô∏è –í—Ä–µ–º–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ë–æ—Ç –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å.")

if __name__ == "__main__":
    try:
        main()
    except RecursionError as e:
        logger.critical(f"–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –†–ï–ö–£–†–°–ò–ò: {e}")
        st.error("""
        üö® –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ —Ä–µ–∫—É—Ä—Å–∏–∏! 
        –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.
        """)
    except Exception as e:
        logger.critical(f"–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: {e}")
        st.error("""
        üö® –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞! 
        –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.
        """)
