import streamlit as st
import pandas as pd
import ccxt
import requests
import time
import json
import logging
import threading
import re
import random
import os
import sys
import gc
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import pandas_ta as ta
from bs4 import BeautifulSoup
import numpy as np

# 🔧 УВЕЛИЧИВАЕМ ЛИМИТ РЕКУРСИИ ДЛЯ STREAMLIT
sys.setrecursionlimit(2000)

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('trading_bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# 🔧 КЛАСС ДЛЯ УПРАВЛЕНИЯ СОСТОЯНИЕМ БЕЗ РЕКУРСИИ
class BotStateManager:
    """Менеджер состояния бота для предотвращения рекурсии"""
    
    def __init__(self):
        self._state = {}
        self._lock = threading.Lock()
        self._last_cleanup = datetime.now()
    
    def get(self, key, default=None):
        with self._lock:
            return self._state.get(key, default)
    
    def set(self, key, value):
        with self._lock:
            self._state[key] = value
            
            # 🔧 АВТООЧИСТКА СТАРЫХ ДАННЫХ КАЖДЫЕ 2 ЧАСА
            if (datetime.now() - self._last_cleanup) > timedelta(hours=2):
                self._cleanup_old_data()
                self._last_cleanup = datetime.now()
    
    def _cleanup_old_data(self):
        """Очистка старых данных для предотвращения утечек памяти"""
        keys_to_remove = []
        current_time = datetime.now()
        
        for key, value in self._state.items():
            if isinstance(value, dict) and 'timestamp' in value:
                try:
                    value_time = datetime.fromisoformat(value['timestamp'])
                    if (current_time - value_time) > timedelta(hours=6):
                        keys_to_remove.append(key)
                except:
                    keys_to_remove.append(key)
        
        for key in keys_to_remove:
            del self._state[key]
        
        if keys_to_remove:
            logger.info(f"🧹 Очищено {len(keys_to_remove)} устаревших записей состояния")

# 🔧 СОЗДАЕМ ГЛОБАЛЬНЫЙ МЕНЕДЖЕР СОСТОЯНИЯ
state_manager = BotStateManager()

class FreeSocialSentimentAnalyzer:
    """Улучшенный анализатор настроений с NLP и весами"""
    
    def __init__(self):
        self.cache = {}
        self.methods = [
            self.coingecko_sentiment,
            self.lunarcrush_sentiment, 
            self.crypto_news_sentiment,
        ]
        self.weights = [0.4, 0.3, 0.3]
        self._last_cache_cleanup = datetime.now()
    
    def _cleanup_old_cache(self):
        """Очистка старого кэша для предотвращения утечек памяти"""
        if (datetime.now() - self._last_cache_cleanup) > timedelta(hours=1):
            keys_to_remove = []
            current_time = datetime.now()
            
            for key in list(self.cache.keys()):
                # Удаляем записи старше 2 часов
                if '_' in key:
                    try:
                        time_str = key.split('_')[-1]
                        cache_time = datetime.strptime(time_str, '%Y%m%d%H')
                        if (current_time - cache_time) > timedelta(hours=2):
                            keys_to_remove.append(key)
                    except:
                        keys_to_remove.append(key)
            
            for key in keys_to_remove:
                if key in self.cache:
                    del self.cache[key]
            
            if keys_to_remove:
                logger.info(f"🧹 Очищено {len(keys_to_remove)} устаревших кэшей настроений")
            
            self._last_cache_cleanup = datetime.now()

    def get_aggregate_sentiment(self, symbol: str) -> Dict:
        """Агрегированный анализ с весами"""
        
        self._cleanup_old_cache()
        
        cache_key = f"{symbol}_{datetime.now().strftime('%Y%m%d%H')}"
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        weighted_scores = []
        successful_methods = []
        method_scores = []
        
        for method, weight in zip(self.methods, self.weights):
            try:
                result = method(symbol)
                if result and result.get('sentiment_score') is not None:
                    weighted_score = result['sentiment_score'] * weight
                    weighted_scores.append(weighted_score)
                    successful_methods.append(result['method'])
                    method_scores.append(result['sentiment_score'])
            except Exception as e:
                logger.debug(f"Method {method.__name__} failed: {e}")
                continue
        
        if weighted_scores:
            final_score = sum(weighted_scores)
            
            # Определяем силу сигнала
            if final_score > 0.25:
                sentiment = 'STRONGLY_BULLISH'
            elif final_score > 0.1:
                sentiment = 'BULLISH' 
            elif final_score < -0.25:
                sentiment = 'STRONGLY_BEARISH'
            elif final_score < -0.1:
                sentiment = 'BEARISH'
            else:
                sentiment = 'NEUTRAL'
            
            confidence = min(len(successful_methods) * 0.3, 0.9)
            
            # Если общая уверенность < 0.2 - игнорируем как guard
            if confidence < 0.2:
                sentiment = 'NEUTRAL'
                final_score = 0
            
            result = {
                'sentiment_score': round(final_score, 3),
                'overall_sentiment': sentiment,
                'methods_used': successful_methods,
                'methods_count': len(successful_methods),
                'confidence': confidence,
                'method_scores': method_scores,
                'timestamp': datetime.now().isoformat()
            }
            
            self.cache[cache_key] = result
            return result
        
        return {
            'sentiment_score': 0,
            'overall_sentiment': 'NEUTRAL', 
            'methods_used': [],
            'methods_count': 0,
            'confidence': 0.1,
            'timestamp': datetime.now().isoformat()
        }
    
    def coingecko_sentiment(self, symbol: str) -> Dict:
        """CoinGecko API - полностью бесплатно без ключа"""
        
        coin_id_map = {
            'BTC/USDT:USDT': 'bitcoin',
            'ETH/USDT:USDT': 'ethereum', 
            'SOL/USDT:USDT': 'solana',
            'DOGE/USDT:USDT': 'dogecoin',
            'XRP/USDT:USDT': 'ripple',
            'ADA/USDT:USDT': 'cardano',
            'AVAX/USDT:USDT': 'avalanche-2',
            'DOT/USDT:USDT': 'polkadot',
            'LINK/USDT:USDT': 'chainlink',
            'MATIC/USDT:USDT': 'matic-network',
            'BNB/USDT:USDT': 'binancecoin',
            'LTC/USDT:USDT': 'litecoin',
            'ATOM/USDT:USDT': 'cosmos',
            'ETC/USDT:USDT': 'ethereum-classic',
            'BCH/USDT:USDT': 'bitcoin-cash',
            'FIL/USDT:USDT': 'filecoin',
            'NEAR/USDT:USDT': 'near',
            'ALGO/USDT:USDT': 'algorand',
            'VET/USDT:USDT': 'vechain',
            'THETA/USDT:USDT': 'theta-token',
            'EOS/USDT:USDT': 'eos',
            'XTZ/USDT:USDT': 'tezos'
        }
        
        coin_id = coin_id_map.get(symbol)
        if not coin_id:
            return {'sentiment_score': 0, 'method': 'coingecko'}
        
        try:
            # TRENDING API - самые обсуждаемые монеты
            trending_url = "https://api.coingecko.com/api/v3/search/trending"
            trending_response = requests.get(trending_url, timeout=10)
            
            trending_score = 0
            is_trending = False
            if trending_response.status_code == 200:
                trending_data = trending_response.json()
                trending_coins = [coin['item']['id'] for coin in trending_data['coins'][:10]]
                
                # Если наша монета в тренде - bullish сигнал
                is_trending = coin_id in trending_coins
                trending_score = 0.3 if is_trending else -0.1

            # Community Data
            community_url = f"https://api.coingecko.com/api/v3/coins/{coin_id}?localization=false&tickers=false&community_data=true&developer_data=false"
            community_response = requests.get(community_url, timeout=10)
            
            community_score = 0
            if community_response.status_code == 200:
                community_data = community_response.json()
                
                # Анализ социальных метрик
                twitter_followers = community_data.get('community_data', {}).get('twitter_followers', 0)
                reddit_subscribers = community_data.get('community_data', {}).get('reddit_subscribers', 0)
                reddit_active_users = community_data.get('community_data', {}).get('reddit_accounts_active_48h', 0)
                
                # Оценка активности сообщества
                if reddit_active_users > 1000:
                    community_score += 0.2
                elif reddit_active_users > 100:
                    community_score += 0.1
                    
                if twitter_followers > 100000:
                    community_score += 0.1
                    
            final_score = trending_score + community_score
                    
            return {
                'sentiment_score': max(min(final_score, 0.5), -0.3),
                'method': 'coingecko',
                'is_trending': is_trending,
                'social_activity': 'HIGH' if community_score > 0.2 else 'MEDIUM' if community_score > 0.1 else 'LOW'
            }
            
        except Exception as e:
            logger.warning(f"CoinGecko API error: {e}")
            return {'sentiment_score': 0, 'method': 'coingecko'}
    
    def lunarcrush_sentiment(self, symbol: str) -> Dict:
        """LunarCrush - бесплатный план с базовыми метриками"""
        
        coin_symbol_map = {
            'BTC/USDT:USDT': 'BTC',
            'ETH/USDT:USDT': 'ETH',
            'SOL/USDT:USDT': 'SOL', 
            'DOGE/USDT:USDT': 'DOGE',
            'XRP/USDT:USDT': 'XRP',
            'ADA/USDT:USDT': 'ADA',
            'AVAX/USDT:USDT': 'AVAX',
            'DOT/USDT:USDT': 'DOT', 
            'LINK/USDT:USDT': 'LINK',
            'MATIC/USDT:USDT': 'MATIC',
            'BNB/USDT:USDT': 'BNB',
            'LTC/USDT:USDT': 'LTC',
            'ATOM/USDT:USDT': 'ATOM',
            'ETC/USDT:USDT': 'ETC',
            'BCH/USDT:USDT': 'BCH',
            'FIL/USDT:USDT': 'FIL',
            'NEAR/USDT:USDT': 'NEAR',
            'ALGO/USDT:USDT': 'ALGO',
            'VET/USDT:USDT': 'VET',
            'THETA/USDT:USDT': 'THETA',
            'EOS/USDT:USDT': 'EOS',
            'XTZ/USDT:USDT': 'XTZ'
        }
        
        coin_symbol = coin_symbol_map.get(symbol)
        if not coin_symbol:
            return {'sentiment_score': 0, 'method': 'lunarcrush'}
        
        try:
            # Базовые метрики доступны без ключа
            url = f"https://lunarcrush.com/api3/coins/{coin_symbol}"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }
            
            response = requests.get(url, headers=headers, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Извлекаем социальные метрики
                social_impact = data.get('data', {}).get('social_impact', 0)
                social_score = data.get('data', {}).get('social_score', 0)
                social_volume = data.get('data', {}).get('social_volume', 0)
                
                # Нормализуем score
                if social_score > 0:
                    normalized_score = min(social_score / 100, 1.0)
                else:
                    normalized_score = 0
                    
                return {
                    'sentiment_score': normalized_score * 0.5,  # Scale down
                    'method': 'lunarcrush', 
                    'social_impact': social_impact,
                    'social_volume': social_volume,
                    'social_score': social_score
                }
                
        except Exception as e:
            logger.warning(f"LunarCrush error: {e}")
        
        return {'sentiment_score': 0, 'method': 'lunarcrush'}
    
    def crypto_news_sentiment(self, symbol: str) -> Dict:
        """Улучшенный анализ настроений через скрапинг крипто-новостей"""
        
        crypto_name = symbol.replace('/USDT', '').upper()
        
        news_sources = [
            f"https://cointelegraph.com/tags/{crypto_name.lower()}",
            f"https://www.coindesk.com/tag/{crypto_name.lower()}",
            f"https://cryptonews.com/news/{crypto_name.lower()}-news/",
        ]
        
        sentiment_scores = []
        
        for url in news_sources:
            try:
                headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                }
                
                response = requests.get(url, headers=headers, timeout=15)
                if response.status_code == 200:
                    soup = BeautifulSoup(response.content, 'html.parser')
                    text_content = soup.get_text().lower()
                    
                    # Улучшенный анализ тональности по ключевым словам
                    positive_indicators = [
                        'partnership', 'adoption', 'integration', 'launch', 'update', 'upgrade',
                        'bullish', 'surge', 'rally', 'breakout', 'growth', 'positive', 'optimistic',
                        'success', 'win', 'gain', 'profit', 'recovery', 'rebound', 'soar',
                        'institutional', 'adoption', 'partnership', 'listing', 'burn'
                    ]
                    
                    negative_indicators = [
                        'hack', 'exploit', 'delay', 'lawsuit', 'regulation', 'bearish', 'ban',
                        'drop', 'crash', 'warning', 'risk', 'negative', 'concern', 'fud',
                        'loss', 'fail', 'problem', 'issue', 'down', 'sell-off', 'dump',
                        'investigation', 'sec', 'legal', 'bankruptcy', 'liquidation'
                    ]
                    
                    # Взвешенный подсчет
                    positive_count = sum(2 for word in positive_indicators if word in text_content)
                    negative_count = sum(2 for word in negative_indicators if word in text_content)
                    
                    # Учитываем контекстные слова
                    strong_positive = ['moon', 'rocket', 'explode', 'breakout']
                    strong_negative = ['collapse', 'plummet', 'crash', 'doom']
                    
                    positive_count += sum(3 for word in strong_positive if word in text_content)
                    negative_count += sum(3 for word in strong_negative if word in text_content)
                    
                    total = positive_count + negative_count
                    if total > 0:
                        score = (positive_count - negative_count) / total
                        sentiment_scores.append(min(max(score, -1), 1))  # Нормализация
                        
            except Exception as e:
                logger.debug(f"News scraping failed for {url}: {e}")
                continue
        
        if sentiment_scores:
            avg_score = sum(sentiment_scores) / len(sentiment_scores)
            return {
                'sentiment_score': avg_score,
                'method': 'crypto_news',
                'sources_analyzed': len(sentiment_scores)
            }
        
        return {'sentiment_score': 0, 'method': 'crypto_news'}

class BybitFuturesTrader:
    def __init__(self, api_key: str, secret: str, testnet: bool = False):
        self.exchange = ccxt.bybit({
            'apiKey': api_key,
            'secret': secret,
            'sandbox': testnet,
            'enableRateLimit': True,
            'options': {
                'defaultType': 'linear',
                'adjustForTimeDifference': True,
                'recvWindow': 10000,
            }
        })
        self.last_trade_time = {}
        self.symbol_precision = {}
        self.max_open_positions = 5
        self._last_memory_cleanup = datetime.now()
        logger.info("Bybit Futures Trader инициализирован")

    def _cleanup_old_data(self):
        """Очистка старых данных для предотвращения утечек памяти"""
        if (datetime.now() - self._last_memory_cleanup) > timedelta(hours=1):
            current_time = datetime.now()
            keys_to_remove = []
            
            for symbol, last_time in list(self.last_trade_time.items()):
                if (current_time - last_time) > timedelta(hours=6):
                    keys_to_remove.append(symbol)
            
            for symbol in keys_to_remove:
                if symbol in self.last_trade_time:
                    del self.last_trade_time[symbol]
                if symbol in self.symbol_precision:
                    del self.symbol_precision[symbol]
            
            if keys_to_remove:
                logger.info(f"🧹 Очищено {len(keys_to_remove)} устаревших записей трейдера")
            
            self._last_memory_cleanup = datetime.now()

    def set_leverage(self, symbol: str, leverage: int):
        try:
            clean_symbol = self._clean_symbol(symbol)
            self.exchange.set_leverage(leverage, clean_symbol, params={'category': 'linear'})
            logger.info(f"Плечо установлено: {clean_symbol} x{leverage}")
            return True
        except Exception as e:
            logger.warning(f"Ошибка установки плеча: {e}")
            return True

    def _clean_symbol(self, symbol: str) -> str:
        if ':' in symbol:
            symbol = symbol.split(':')[0]
        clean = symbol.replace('/', '')
        if not clean.endswith('USDT'):
            clean += 'USDT'
        return clean

    def get_symbol_precision(self, symbol: str) -> float:
        try:
            if symbol in self.symbol_precision:
                return self.symbol_precision[symbol]
            
            clean_symbol = self._clean_symbol(symbol)
            markets = self.exchange.load_markets()
            market = markets.get(clean_symbol)
            
            if market and 'precision' in market and 'amount' in market['precision']:
                precision = market['precision']['amount']
                min_amount = 10 ** -precision if precision > 0 else 0.1
                self.symbol_precision[symbol] = min_amount
                logger.info(f"Точность для {symbol}: {min_amount}")
                return min_amount
            
            default_precisions = {
                'BTC/USDT:USDT': 0.001,
                'ETH/USDT:USDT': 0.01,
                'SOL/USDT:USDT': 0.1,
                'XRP/USDT:USDT': 1,
                'ADA/USDT:USDT': 1,
                'AVAX/USDT:USDT': 0.1,
                'DOGE/USDT:USDT': 1,
                'DOT/USDT:USDT': 0.1,
                'LINK/USDT:USDT': 0.1,
                'MATIC/USDT:USDT': 1,
                'BNB/USDT:USDT': 0.01,
                'LTC/USDT:USDT': 0.01,
                'ATOM/USDT:USDT': 0.1,
                'ETC/USDT:USDT': 0.1,
                'BCH/USDT:USDT': 0.001,
                'FIL/USDT:USDT': 0.1,
                'NEAR/USDT:USDT': 0.1,
                'ALGO/USDT:USDT': 1,
                'VET/USDT:USDT': 1,
                'THETA/USDT:USDT': 1,
                'EOS/USDT:USDT': 0.1,
                'XTZ/USDT:USDT': 0.1,
            }
            
            min_amount = default_precisions.get(symbol, 0.1)
            self.symbol_precision[symbol] = min_amount
            return min_amount
            
        except Exception as e:
            logger.error(f"Ошибка получения точности для {symbol}: {e}")
            return 0.1

    def adjust_amount_to_precision(self, symbol: str, amount: float) -> float:
        min_amount = self.get_symbol_precision(symbol)
        adjusted_amount = max(amount, min_amount)
        
        if min_amount >= 1:
            adjusted_amount = int(adjusted_amount)
        elif min_amount >= 0.1:
            adjusted_amount = round(adjusted_amount, 1)
        elif min_amount >= 0.01:
            adjusted_amount = round(adjusted_amount, 2)
        elif min_amount >= 0.001:
            adjusted_amount = round(adjusted_amount, 3)
        else:
            adjusted_amount = round(adjusted_amount, 4)
        
        if adjusted_amount != amount:
            logger.info(f"Скорректирован размер {symbol}: {amount} -> {adjusted_amount}")
        
        return adjusted_amount

    def get_balance(self):
        try:
            balance = self.exchange.fetch_balance({'type': 'UNIFIED'})
            usdt_balance = balance.get('USDT', {}).get('free', 0) or balance.get('total', {}).get('USDT', 0)
            final_balance = float(usdt_balance) if usdt_balance else 0.0
            logger.info(f"Баланс: {final_balance} USDT")
            return final_balance
        except Exception as e:
            logger.error(f"Ошибка получения баланса: {e}")
            return 0.0

    def create_order(self, symbol: str, order_type: str, side: str, amount: float, price: float = None, take_profit: float = None, stop_loss: float = None):
        try:
            current_time = datetime.now()
            if symbol in self.last_trade_time:
                time_since_last_trade = current_time - self.last_trade_time[symbol]
                if time_since_last_trade < timedelta(minutes=3):
                    logger.warning(f"Слишком частая торговля для {symbol}. Пропускаем.")
                    return None

            clean_symbol = self._clean_symbol(symbol)
            current_price = price or self.get_ticker(symbol)
            
            if current_price <= 0:
                logger.error(f"Некорректная цена для {symbol}: {current_price}")
                return None

            balance = self.get_balance()
            
            adjusted_amount = self.adjust_amount_to_precision(symbol, amount)
            
            if adjusted_amount < self.get_symbol_precision(symbol):
                logger.error(f"Скорректированный размер слишком мал для {symbol}: {adjusted_amount}")
                return None

            order_value = adjusted_amount * current_price
            
            if balance < 100:
                required_margin = order_value * 0.05
            else:
                required_margin = order_value * 0.1
                
            if balance < required_margin:
                logger.error(f"Недостаточно баланса: {balance} < {required_margin}")
                return None

            positions = self.get_positions()
            if len(positions) >= self.max_open_positions:
                logger.warning(f"Достигнут лимит открытых позиций: {len(positions)}/{self.max_open_positions}")
                return None

            # Фикс SL/TP
            if side == 'buy':
                if stop_loss and stop_loss >= current_price:
                    stop_loss = current_price * 0.99
                    logger.warning(f"Скорректирован SL для BUY: {stop_loss}")
                if take_profit and take_profit <= current_price:
                    take_profit = current_price * 1.01
                    logger.warning(f"Скорректирован TP для BUY: {take_profit}")
            elif side == 'sell':
                if stop_loss and stop_loss <= current_price:
                    stop_loss = current_price * 1.01
                    logger.warning(f"Скорректирован SL для SELL: {stop_loss}")
                if take_profit and take_profit >= current_price:
                    take_profit = current_price * 0.99
                    logger.warning(f"Скорректирован TP для SELL: {take_profit}")

            params = {'category': 'linear', 'timeInForce': 'GTC'}
            
            if take_profit:
                params['takeProfit'] = take_profit
            if stop_loss:
                params['stopLoss'] = stop_loss

            logger.info(f"Создание ордера: {clean_symbol} {side} {adjusted_amount} @ {current_price} | TP: {take_profit} SL: {stop_loss}")
            
            order = self.exchange.create_order(
                symbol=clean_symbol, type=order_type, side=side,
                amount=adjusted_amount, params=params
            )

            self.last_trade_time[symbol] = current_time
            logger.info(f"ОРДЕР ИСПОЛНЕН: {side} {adjusted_amount} {clean_symbol} @ {current_price:.4f}")
            return order
            
        except Exception as e:
            logger.error(f"Ошибка создания ордера: {e}")
            return None

    def get_ticker(self, symbol: str):
        try:
            clean_symbol = self._clean_symbol(symbol)
            ticker = self.exchange.fetch_ticker(clean_symbol)
            price = float(ticker.get('last', 0))
            return price
        except Exception as e:
            logger.error(f"Ошибка получения цены {symbol}: {e}")
            return 0.0

    def get_positions(self):
        try:
            positions = self.exchange.fetch_positions(None, {'category': 'linear'})
            active_positions = []
            for pos in positions:
                if pos['contracts'] and float(pos['contracts']) > 0:
                    active_positions.append({
                        'symbol': pos['symbol'],
                        'side': 'long' if float(pos['contracts']) > 0 else 'short',
                        'size': float(pos['contracts']),
                        'entry_price': float(pos['entryPrice']),
                        'unrealized_pnl': float(pos.get('unrealizedPnl', 0)),
                        'leverage': float(pos.get('leverage', 1))
                    })
            return active_positions
        except Exception as e:
            logger.error(f"Ошибка получения позиций: {e}")
            return []

    def get_open_orders(self, symbol: str = None):
        try:
            params = {'category': 'linear'}
            if symbol:
                clean_symbol = self._clean_symbol(symbol)
                orders = self.exchange.fetch_open_orders(clean_symbol, params=params)
            else:
                orders = self.exchange.fetch_open_orders(params=params)
            return orders
        except Exception as e:
            logger.error(f"Ошибка получения ордеров: {e}")
            return []

    def get_account_info(self):
        """🔧 ИСПРАВЛЕННАЯ ВЕРСИЯ БЕЗ РЕКУРСИИ"""
        try:
            self._cleanup_old_data()
            
            balance = self.get_balance()
            positions = self.get_positions()
            orders = self.get_open_orders()
            
            total_margin_used = 0
            total_unrealized_pnl = 0
            
            for pos in positions:
                try:
                    size = float(pos.get('size', 0))
                    entry_price = float(pos.get('entry_price', 0))
                    leverage = max(float(pos.get('leverage', 1)), 1)
                    
                    if size > 0 and entry_price > 0:
                        total_margin_used += (size * entry_price) / leverage
                    total_unrealized_pnl += pos.get('unrealized_pnl', 0)
                except (ValueError, TypeError) as e:
                    logger.warning(f"Ошибка расчета маржи для позиции: {e}")
                    continue
            
            available_balance = max(balance - total_margin_used, 0)
            
            return {
                'total_balance': balance,
                'available_balance': available_balance,
                'margin_used': total_margin_used,
                'positions_count': len(positions),
                'orders_count': len(orders),
                'unrealized_pnl': total_unrealized_pnl,
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            logger.error(f"Ошибка получения информации: {e}")
            return {
                'total_balance': 0.0, 'available_balance': 0.0, 'margin_used': 0.0,
                'positions_count': 0, 'orders_count': 0, 'unrealized_pnl': 0.0
            }

class AdvancedTechnicalAnalyzer:
    """Улучшенный технический анализ с ADX"""
    
    def __init__(self):
        self._analysis_cache = {}
        self._last_cache_cleanup = datetime.now()
        logger.info("Advanced Technical Analyzer инициализирован")
    
    def _cleanup_old_cache(self):
        """Очистка старого кэша анализа"""
        if (datetime.now() - self._last_cache_cleanup) > timedelta(minutes=30):
            keys_to_remove = []
            current_time = datetime.now()
            
            for key in list(self._analysis_cache.keys()):
                cache_data = self._analysis_cache.get(key, {})
                if isinstance(cache_data, dict) and 'timestamp' in cache_data:
                    try:
                        cache_time = datetime.fromisoformat(cache_data['timestamp'])
                        if (current_time - cache_time) > timedelta(hours=1):
                            keys_to_remove.append(key)
                    except:
                        keys_to_remove.append(key)
            
            for key in keys_to_remove:
                if key in self._analysis_cache:
                    del self._analysis_cache[key]
            
            if keys_to_remove:
                logger.debug(f"🧹 Очищено {len(keys_to_remove)} устаревших кэшей анализа")
            
            self._last_cache_cleanup = datetime.now()

    def get_multi_timeframe_analysis(self, symbol: str, exchange) -> Dict:
        """Улучшенный анализ на нескольких таймфреймах с ADX"""
        
        self._cleanup_old_cache()
        
        cache_key = f"{symbol}_analysis"
        cached_data = self._analysis_cache.get(cache_key)
        
        if cached_data and (datetime.now() - datetime.fromisoformat(cached_data.get('timestamp', '2000-01-01'))) < timedelta(minutes=5):
            return cached_data['data']
        
        try:
            clean_symbol = self._clean_symbol(symbol)
            
            analysis = {}
            
            # 1. ДОЛГОСРОЧНЫЙ тренд (4h, 1d) - для Grok
            analysis['trend'] = self._analyze_primary_trend(clean_symbol, exchange)
            
            # 2. СРЕДНЕСРОЧНЫЙ сигнал (1h) - для входа с ADX
            analysis['entry'] = self._analyze_entry_signals(clean_symbol, exchange)
            
            # 3. КРАТКОСРОЧНЫЙ вход (15m) - для точного исполнения
            analysis['execution'] = self._analyze_execution_signals(clean_symbol, exchange)
            
            # 4. Волатильность и риск с ADX
            analysis['risk'] = self._analyze_risk_parameters(clean_symbol, exchange)
            
            # Сохраняем в кэш
            self._analysis_cache[cache_key] = {
                'data': analysis,
                'timestamp': datetime.now().isoformat()
            }
            
            return analysis
            
        except Exception as e:
            logger.error(f"Ошибка multi-timeframe анализа {symbol}: {e}")
            return self._get_fallback_analysis()
    
    def _analyze_primary_trend(self, symbol: str, exchange) -> Dict:
        """Анализ основного тренда на 4h/1d с ADX"""
        try:
            ohlcv_4h = exchange.fetch_ohlcv(symbol, '4h', limit=100)
            ohlcv_1d = exchange.fetch_ohlcv(symbol, '1d', limit=100)
            
            if not ohlcv_4h or not ohlcv_1d:
                return {'trend': 'NEUTRAL', 'strength': 0.5, 'timeframe': '4h', 'adx': 0}
            
            df_4h = pd.DataFrame(ohlcv_4h, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df_1d = pd.DataFrame(ohlcv_1d, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # EMA анализ для тренда
            df_4h['ema_20'] = ta.ema(df_4h['close'], length=20)
            df_4h['ema_50'] = ta.ema(df_4h['close'], length=50)
            df_1d['ema_20'] = ta.ema(df_1d['close'], length=20)
            df_1d['ema_50'] = ta.ema(df_1d['close'], length=50)
            
            # ADX для силы тренда
            df_4h_adx = ta.adx(df_4h['high'], df_4h['low'], df_4h['close'], length=14)
            df_1d_adx = ta.adx(df_1d['high'], df_1d['low'], df_1d['close'], length=14)
            
            adx_4h = df_4h_adx['ADX_14'].iloc[-1] if not df_4h_adx.empty else 0
            adx_1d = df_1d_adx['ADX_14'].iloc[-1] if not df_1d_adx.empty else 0
            
            # Сила тренда с учетом ADX
            trend_strength_4h = self._calculate_trend_strength(df_4h, adx_4h)
            trend_strength_1d = self._calculate_trend_strength(df_1d, adx_1d)
            
            # Совмещенный тренд
            combined_strength = (trend_strength_4h + trend_strength_1d) / 2
            
            if combined_strength > 0.6:
                trend = "BULLISH"
            elif combined_strength < -0.6:
                trend = "BEARISH"
            else:
                trend = "RANGING"
            
            avg_adx = (adx_4h + adx_1d) / 2
            
            return {
                'trend': trend,
                'strength': abs(combined_strength),
                'timeframe': '4h/1d',
                'price_4h': df_4h['close'].iloc[-1],
                'price_1d': df_1d['close'].iloc[-1],
                'adx': avg_adx,
                'adx_strength': 'STRONG' if avg_adx > 25 else 'MODERATE' if avg_adx > 20 else 'WEAK'
            }
            
        except Exception as e:
            logger.error(f"Ошибка анализа тренда: {e}")
            return {'trend': 'NEUTRAL', 'strength': 0.5, 'timeframe': '4h', 'adx': 0}
    
    def _analyze_entry_signals(self, symbol: str, exchange) -> Dict:
        """УЛУЧШЕННЫЙ анализ сигналов входа с детальной диагностикой"""
        try:
            ohlcv_1h = exchange.fetch_ohlcv(symbol, '1h', limit=50)
            
            if not ohlcv_1h or len(ohlcv_1h) < 20:
                return {'action': 'HOLD', 'confidence': 0.5, 'reason': 'Insufficient data'}
            
            df = pd.DataFrame(ohlcv_1h, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # Оптимизированные индикаторы для крипто
            df['rsi'] = ta.rsi(df['close'], length=14)
            df['macd'] = ta.macd(df['close'])['MACD_12_26_9']
            
            # ADX для силы тренда
            adx_data = ta.adx(df['high'], df['low'], df['close'], length=14)
            df['adx'] = adx_data['ADX_14']
            
            df['bb_upper'] = ta.bbands(df['close'], length=20, std=2)['BBU_20_2.0']
            df['bb_lower'] = ta.bbands(df['close'], length=20, std=2)['BBL_20_2.0']
            df['atr'] = ta.atr(df['high'], df['low'], df['close'], length=14)
            
            current_rsi = df['rsi'].iloc[-1]
            current_macd = df['macd'].iloc[-1]
            current_price = df['close'].iloc[-1]
            atr = df['atr'].iloc[-1]
            current_adx = df['adx'].iloc[-1]
            
            # УЛУЧШЕННАЯ система сигналов с весами
            buy_signals = 0
            sell_signals = 0
            
            # Оптимизированные RSI сигналы (расслабленные thresholds)
            if current_rsi < 35:
                buy_signals += 2
            elif current_rsi < 45:
                buy_signals += 1
            elif current_rsi > 65:
                sell_signals += 2
            elif current_rsi > 55:
                sell_signals += 1
            
            # MACD сигналы
            if current_macd > 0 and df['macd'].iloc[-2] <= 0:
                buy_signals += 1
            elif current_macd < 0 and df['macd'].iloc[-2] >= 0:
                sell_signals += 1
            
            # Bollinger Bands
            if current_price <= df['bb_lower'].iloc[-1]:
                buy_signals += 1
            elif current_price >= df['bb_upper'].iloc[-1]:
                sell_signals += 1
            
            # ADX фильтр - усиливаем сигналы при сильном тренде
            adx_multiplier = 1.5 if current_adx > 25 else 1.2 if current_adx > 20 else 1.0
            
            # ВЗВЕШЕННАЯ система вместо простого подсчета
            weighted_buy_score = (buy_signals * adx_multiplier)
            weighted_sell_score = (sell_signals * adx_multiplier)
            
            # УЛУЧШЕННЫЕ условия для действий (ослабленные пороги)
            if weighted_buy_score >= 2.0:  # Было 3.0
                action = 'BUY'
                confidence = min((weighted_buy_score + 1) / 5.0, 0.9)  # Увеличиваем уверенность
            elif weighted_sell_score >= 2.0:  # Было 3.0
                action = 'SELL'
                confidence = min((weighted_sell_score + 1) / 5.0, 0.9)  # Увеличиваем уверенность
            else:
                action = 'HOLD'
                confidence = 0.3
            
            # Дополнительный буст для сильных сигналов
            if (action == 'BUY' and buy_signals >= 3) or (action == 'SELL' and sell_signals >= 3):
                confidence = min(confidence * 1.2, 0.95)
            
            # 🔍 ДЕТАЛЬНАЯ ДИАГНОСТИКА - ДОБАВЛЕНО
            logger.info(f"🔍 [DIAGNOSTIC] {symbol} - Тех.анализ детали:")
            logger.info(f"   📊 Цена: {current_price:.4f}, RSI: {current_rsi:.1f}")
            logger.info(f"   📈 MACD: {current_macd:.6f}, ADX: {current_adx:.1f}")
            logger.info(f"   📉 ATR: {atr:.4f}")
            
            # Анализ положения в Bollinger Bands
            bb_position = ((current_price - df['bb_lower'].iloc[-1]) / 
                          (df['bb_upper'].iloc[-1] - df['bb_lower'].iloc[-1]))
            logger.info(f"   🎯 BB Position: {bb_position:.2f} (0=lower, 1=upper)")
            
            logger.info(f"   ✅ BUY сырые сигналы: {buy_signals}")
            logger.info(f"   ❌ SELL сырые сигналы: {sell_signals}")
            logger.info(f"   🎯 Weighted scores: BUY={weighted_buy_score:.2f}, SELL={weighted_sell_score:.2f}")
            logger.info(f"   📋 Final decision: {action} (conf: {confidence:.2f})")
            
            return {
                'action': action,
                'confidence': confidence,
                'rsi': current_rsi,
                'macd': current_macd,
                'atr': atr,
                'adx': current_adx,
                'price': current_price,
                'signals': {
                    'buy': weighted_buy_score, 
                    'sell': weighted_sell_score,
                    'raw_buy': buy_signals,
                    'raw_sell': sell_signals
                }
            }
            
        except Exception as e:
            logger.error(f"Ошибка анализа входа: {e}")
            return {'action': 'HOLD', 'confidence': 0.3, 'reason': 'Analysis error'}
    
    def _analyze_execution_signals(self, symbol: str, exchange) -> Dict:
        """Анализ для точного исполнения на 15m"""
        try:
            ohlcv_15m = exchange.fetch_ohlcv(symbol, '15m', limit=30)
            
            if not ohlcv_15m or len(ohlcv_15m) < 10:
                return {'optimal_entry': None, 'confidence': 0.5}
            
            df = pd.DataFrame(ohlcv_15m, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # Анализ для точного входа
            df['ema_9'] = ta.ema(df['close'], length=9)
            df['ema_21'] = ta.ema(df['close'], length=21)
            df['rsi_14'] = ta.rsi(df['close'], length=14)
            
            current_price = df['close'].iloc[-1]
            ema_9 = df['ema_9'].iloc[-1]
            ema_21 = df['ema_21'].iloc[-1]
            rsi = df['rsi_14'].iloc[-1]
            
            # Логика точного входа
            if ema_9 > ema_21 and rsi < 60:
                # Бычий тренд, ждем отката
                optimal_entry = max(df['low'].tail(5).min(), ema_21)
                confidence = 0.7
            elif ema_9 < ema_21 and rsi > 40:
                # Медвежий тренд, ждем отскока
                optimal_entry = min(df['high'].tail(5).max(), ema_21)
                confidence = 0.7
            else:
                optimal_entry = current_price
                confidence = 0.4
            
            return {
                'optimal_entry': optimal_entry,
                'confidence': confidence,
                'current_price': current_price,
                'distance_pct': abs((optimal_entry - current_price) / current_price * 100)
            }
            
        except Exception as e:
            logger.error(f"Ошибка анализа исполнения: {e}")
            return {'optimal_entry': None, 'confidence': 0.3}
    
    def _analyze_risk_parameters(self, symbol: str, exchange) -> Dict:
        """Анализ волатильности и параметров риска с ADX"""
        try:
            ohlcv_1h = exchange.fetch_ohlcv(symbol, '1h', limit=50)
            
            if not ohlcv_1h:
                return {'atr': 0, 'volatility': 'LOW', 'risk_level': 'MEDIUM', 'adx': 0}
            
            df = pd.DataFrame(ohlcv_1h, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            
            # ATR для стоп-лосса
            atr = ta.atr(df['high'], df['low'], df['close'], length=14).iloc[-1]
            
            # ADX для силы тренда
            adx_data = ta.adx(df['high'], df['low'], df['close'], length=14)
            adx = adx_data['ADX_14'].iloc[-1] if not adx_data.empty else 0
            
            # Волатильность
            price_changes = df['close'].pct_change().dropna()
            volatility = price_changes.std() * np.sqrt(24)
            
            if volatility > 0.8:
                vol_level = 'HIGH'
                risk_level = 'HIGH'
            elif volatility > 0.4:
                vol_level = 'MEDIUM'
                risk_level = 'MEDIUM'
            else:
                vol_level = 'LOW'
                risk_level = 'LOW'
            
            # Динамический множитель SL на основе ADX
            if adx > 25:
                sl_multiplier = 1.2
                position_size_multiplier = 1.2
            elif adx > 20:
                sl_multiplier = 1.5
                position_size_multiplier = 1.0
            else:
                sl_multiplier = 2.0
                position_size_multiplier = 0.8
            
            return {
                'atr': atr,
                'volatility': vol_level,
                'risk_level': risk_level,
                'volatility_value': volatility,
                'adx': adx,
                'recommended_sl_multiplier': sl_multiplier,
                'position_size_multiplier': position_size_multiplier
            }
            
        except Exception as e:
            logger.error(f"Ошибка анализа риска: {e}")
            return {'atr': 0, 'volatility': 'LOW', 'risk_level': 'MEDIUM', 'adx': 0}
    
    def _calculate_trend_strength(self, df: pd.DataFrame, adx: float) -> float:
        """Расчет силы тренда с учетом ADX"""
        try:
            ema_20 = ta.ema(df['close'], length=20)
            ema_50 = ta.ema(df['close'], length=50)
            sma_20 = ta.sma(df['close'], length=20)
            
            current_ema_20 = ema_20.iloc[-1]
            current_ema_50 = ema_50.iloc[-1]
            current_sma_20 = sma_20.iloc[-1]
            current_price = df['close'].iloc[-1]
            
            ema_trend = 1 if current_ema_20 > current_ema_50 else -1
            price_vs_sma = (current_price - current_sma_20) / current_sma_20
            adx_strength = min(adx / 50.0, 1.0)
            
            trend_strength = ema_trend * (0.6 + abs(price_vs_sma) * 2 + adx_strength * 0.5)
            
            return max(min(trend_strength, 1), -1)
            
        except Exception as e:
            logger.error(f"Ошибка расчета силы тренда: {e}")
            return 0.0
    
    def _clean_symbol(self, symbol: str) -> str:
        if ':' in symbol:
            symbol = symbol.split(':')[0]
        clean = symbol.replace('/', '')
        if not clean.endswith('USDT'):
            clean += 'USDT'
        return clean
    
    def _get_fallback_analysis(self) -> Dict:
        return {
            'trend': {'trend': 'NEUTRAL', 'strength': 0.5, 'timeframe': '4h', 'adx': 0},
            'entry': {'action': 'HOLD', 'confidence': 0.3, 'reason': 'Fallback'},
            'execution': {'optimal_entry': None, 'confidence': 0.3},
            'risk': {'atr': 0, 'volatility': 'LOW', 'risk_level': 'MEDIUM', 'adx': 0}
        }

class GrokTrendFilter:
    """Grok как фильтр долгосрочного тренда"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.endpoint = "https://api.x.ai/v1/chat/completions"
        self.last_analysis_time = {}
        self.cache = {}
        self.daily_calls = 0
        self.max_daily_calls = 20
        self.last_reset_day = datetime.now().date()
        self.initial_analysis_done = False
        self._last_cache_cleanup = datetime.now()
        logger.info("Grok Trend Filter инициализирован")
    
    def _cleanup_old_cache(self):
        """Очистка старого кэша Grok"""
        if (datetime.now() - self._last_cache_cleanup) > timedelta(hours=1):
            keys_to_remove = []
            current_time = datetime.now()
            current_date = current_time.strftime('%Y%m%d')
            
            for key in list(self.cache.keys()):
                if not key.endswith(current_date):
                    keys_to_remove.append(key)
            
            # Очистка старых записей времени анализа
            symbols_to_remove = []
            for symbol, last_time in list(self.last_analysis_time.items()):
                if (current_time - last_time) > timedelta(days=1):
                    symbols_to_remove.append(symbol)
            
            for key in keys_to_remove:
                if key in self.cache:
                    del self.cache[key]
            
            for symbol in symbols_to_remove:
                if symbol in self.last_analysis_time:
                    del self.last_analysis_time[symbol]
            
            if keys_to_remove or symbols_to_remove:
                logger.info(f"🧹 Очищено {len(keys_to_remove)} кэшей и {len(symbols_to_remove)} временных меток Grok")
            
            self._last_cache_cleanup = datetime.now()

    def _reset_daily_counter(self):
        today = datetime.now().date()
        if today != self.last_reset_day:
            self.daily_calls = 0
            self.last_reset_day = today
    
    def perform_initial_analysis(self, symbols: List[str], technical_analyzer, exchange) -> Dict[str, Dict]:
        """Проведение первоначального анализа при запуске бота"""
        logger.info("🎯 Запуск первоначального анализа Grok для всех символов...")
        
        initial_analysis = {}
        successful_analyses = 0
        
        for symbol in symbols:
            try:
                logger.info(f"🔍 Первоначальный анализ Grok для {symbol}...")
                
                # Получаем технические данные
                technical_data = technical_analyzer.get_multi_timeframe_analysis(symbol, exchange)
                
                # Анализ Grok (без учета в дневной лимит)
                analysis = self._analyze_primary_trend_internal(symbol, technical_data, is_initial=True)
                
                if analysis.get('grok_analysis', False):
                    initial_analysis[symbol] = analysis
                    successful_analyses += 1
                    logger.info(f"✅ Первоначальный анализ Grok для {symbol} завершен: {analysis.get('trend')}")
                else:
                    logger.warning(f"❌ Первоначальный анализ Grok для {symbol} не удался")
                
                # Задержка между запросами чтобы не перегружать API
                time.sleep(2)
                
            except Exception as e:
                logger.error(f"Ошибка первоначального анализа для {symbol}: {e}")
                continue
        
        self.initial_analysis_done = True
        logger.info(f"🎯 Первоначальный анализ завершен: {successful_analyses}/{len(symbols)} символов")
        
        return initial_analysis
    
    def analyze_primary_trend(self, symbol: str, technical_data: Dict) -> Dict:
        """Основной метод анализа тренда Grok (учитывается в дневном лимите)"""
        
        self._cleanup_old_cache()
        self._reset_daily_counter()
        
        # Проверяем дневной лимит (только для регулярных анализов, не для первоначальных)
        if self.daily_calls >= self.max_daily_calls and self.initial_analysis_done:
            logger.warning(f"🚫 Достигнут дневной лимит вызовов Grok: {self.daily_calls}/{self.max_daily_calls}")
            return {'trend': 'NEUTRAL', 'confidence': 0.5, 'reasoning': 'Daily limit reached', 'grok_analysis': False}
        
        return self._analyze_primary_trend_internal(symbol, technical_data, is_initial=False)
    
    def _analyze_primary_trend_internal(self, symbol: str, technical_data: Dict, is_initial: bool = False) -> Dict:
        """Внутренний метод анализа тренда Grok"""
        
        cache_key = f"{symbol}_{datetime.now().strftime('%Y%m%d')}"
        if cache_key in self.cache and not is_initial:
            return self.cache[cache_key]
        
        # Cooldown проверка (только для регулярных анализов)
        current_time = datetime.now()
        if not is_initial and symbol in self.last_analysis_time:
            time_since_analysis = current_time - self.last_analysis_time[symbol]
            if time_since_analysis < timedelta(hours=6):
                cached_result = self.cache.get(cache_key, {'trend': 'NEUTRAL', 'confidence': 0.5})
                if cached_result.get('grok_analysis', False):
                    return cached_result
        
        try:
            trend_info = technical_data['trend']
            entry_info = technical_data['entry']
            risk_info = technical_data['risk']
            
            prompt = f"""
Анализ ДОЛГОСРОЧНОГО тренда для {symbol}:
ТЕХНИЧЕСКИЕ ДАННЫЕ:
- Основной тренд: {trend_info['trend']} (сила: {trend_info['strength']:.2f})
- Сила тренда ADX: {trend_info.get('adx', 0):.1f} ({trend_info.get('adx_strength', 'WEAK')})
- Таймфрейм: {trend_info['timeframe']}
- Цена 4h: ${trend_info.get('price_4h', 0):.2f}
- Цена 1d: ${trend_info.get('price_1d', 0):.2f}
СИГНАЛЫ ВХОДА:
- Действие: {entry_info['action']}
- Уверенность: {entry_info['confidence']:.2f}
- RSI: {entry_info.get('rsi', 50):.1f}
- MACD: {entry_info.get('macd', 0):.4f}
- ADX: {entry_info.get('adx', 0):.1f}
РИСК:
- Волатильность: {risk_info['volatility']}
- Уровень риска: {risk_info['risk_level']}
- ADX: {risk_info.get('adx', 0):.1f}
ЗАДАЧА: Определи только ОСНОВНОЙ ТРЕНД (BULLISH/BEARISH/RANGING) и уверенность 0-1.
Учитывай силу тренда по ADX. Не давай конкретных торговых рекомендаций, только тренд.
ОТВЕТ В ФОРМАТЕ JSON: {{"trend": "BULLISH/BEARISH/RANGING", "confidence": 0.XX, "reasoning": "краткое обоснование"}}
"""
            
            messages = [
                {
                    "role": "system", 
                    "content": "Ты аналитик. Определяй только ДОЛГОСРОЧНЫЙ тренд. Учитывай ADX для силы тренда. Не давай торговых советов."
                },
                {
                    "role": "user",
                    "content": prompt
                }
            ]
            
            response = self._call_grok_api(messages)
            analysis = self._parse_grok_response(response)
            
            # Обогащаем анализ
            analysis.update({
                'symbol': symbol,
                'timestamp': datetime.now().isoformat(),
                'grok_analysis': True,
                'is_initial_analysis': is_initial
            })
            
            self.cache[cache_key] = analysis
            self.last_analysis_time[symbol] = current_time
            
            # Увеличиваем счетчик только для регулярных анализов
            if not is_initial:
                self.daily_calls += 1
            
            logger.info(f"🎯 Grok тренд для {symbol}: {analysis.get('trend')} (уверенность: {analysis.get('confidence', 0):.2f}) {'[INITIAL]' if is_initial else ''}")
            
            return analysis
            
        except Exception as e:
            logger.error(f"Ошибка анализа Grok тренда: {e}")
            return {'trend': 'NEUTRAL', 'confidence': 0.5, 'reasoning': 'Ошибка анализа', 'grok_analysis': False}
    
    def should_enter_trade(self, primary_trend: str, entry_signal: str, trend_confidence: float) -> bool:
        """Улучшенная проверка согласованности тренда и сигнала входа"""
        
        if trend_confidence < 0.5:
            return False
        
        if primary_trend == "RANGING":
            return entry_signal in ["BUY", "SELL"]
        
        if primary_trend == "BULLISH" and entry_signal == "BUY":
            return True
        elif primary_trend == "BEARISH" and entry_signal == "SELL":
            return True
        else:
            return False
    
    def get_daily_stats(self) -> Dict:
        """Получение статистики по использованию Grok"""
        return {
            'daily_calls': self.daily_calls,
            'max_daily_calls': self.max_daily_calls,
            'remaining_calls': max(0, self.max_daily_calls - self.daily_calls),
            'initial_analysis_done': self.initial_analysis_done,
            'last_reset_day': self.last_reset_day.isoformat()
        }
    
    def _call_grok_api(self, messages: List[Dict]):
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": "grok-3",
            "messages": messages,
            "temperature": 0.3,
            "max_tokens": 150,
            "top_p": 0.9,
            "stream": False
        }
        
        response = requests.post(
            self.endpoint,
            headers=headers,
            json=payload,
            timeout=30
        )
        
        if response.status_code != 200:
            raise Exception(f"Ошибка API: {response.status_code} - {response.text}")
        
        return response.json()
    
    def _parse_grok_response(self, response: Dict) -> Dict:
        try:
            content = response['choices'][0]['message']['content'].strip()
            if content.startswith('{') and content.endswith('}'):
                return json.loads(content)
            else:
                match = re.search(r'\{.*\}', content, re.DOTALL)
                if match:
                    return json.loads(match.group(0))
                raise ValueError("Некорректный JSON")
        except Exception as e:
            logger.error(f"Ошибка парсинга Grok: {e}")
            return {
                "trend": "NEUTRAL",
                "confidence": 0.5,
                "reasoning": "Ошибка парсинга"
            }

class SocialSentimentGuard:
    """Улучшенные социальные настроения как ЗАЩИТА от сделок"""
    
    def __init__(self):
        self.sentiment_analyzer = FreeSocialSentimentAnalyzer()
        logger.info("Social Sentiment Guard инициализирован")
    
    def should_avoid_trade(self, symbol: str, analysis: Dict) -> Tuple[bool, str]:
        """Улучшенная проверка, следует ли избегать сделки на основе соц.настроений"""
        
        try:
            sentiment_data = self.sentiment_analyzer.get_aggregate_sentiment(symbol)
            action = analysis.get('action')
            primary_trend = analysis.get('primary_trend', {}).get('trend', 'NEUTRAL')
            
            if sentiment_data['confidence'] < 0.2:
                return False, "✅ Соц.настроения слишком слабы для блокировки"
            
            avoidance_conditions = [
                (sentiment_data['overall_sentiment'] == 'STRONGLY_BEARISH' and action == 'BUY', 
                 "🚫 СИЛЬНО негативные настроения при покупке"),
                
                (sentiment_data['overall_sentiment'] == 'STRONGLY_BULLISH' and action == 'SELL',
                 "🚫 СИЛЬНО позитивные настроения при продаже"),
                
                (sentiment_data['overall_sentiment'] == 'BEARISH' and primary_trend == 'BULLISH' and action == 'BUY' and sentiment_data['confidence'] > 0.5,
                 "⚠️ Сильные негативные настроения конфликтуют с бычьим трендом"),
                
                (sentiment_data['overall_sentiment'] == 'BULLISH' and primary_trend == 'BEARISH' and action == 'SELL' and sentiment_data['confidence'] > 0.5,
                 "⚠️ Сильные позитивные настроения конфликтуют с медвежьим трендом"),
                
                (sentiment_data['sentiment_score'] < -0.3 and action == 'BUY' and sentiment_data['confidence'] > 0.4,
                 "🚫 Очень низкий sentiment score для покупки"),
                
                (sentiment_data['sentiment_score'] > 0.3 and action == 'SELL' and sentiment_data['confidence'] > 0.4,
                 "🚫 Очень высокий sentiment score для продажи")
            ]
            
            for condition, reason in avoidance_conditions:
                if condition:
                    logger.warning(f"Соц.защита для {symbol}: {reason}")
                    return True, reason
            
            if ((sentiment_data['overall_sentiment'] == 'BULLISH' and action == 'BUY') or
                (sentiment_data['overall_sentiment'] == 'BEARISH' and action == 'SELL')):
                analysis['confidence'] = min(analysis['confidence'] * 1.1, 0.95)
                analysis['reasoning'] = analysis.get('reasoning', '') + f" | ✅ Подтверждено соц.настроениями"
            
            return False, "✅ Соц.настроения не блокируют сделку"
            
        except Exception as e:
            logger.error(f"Ошибка соц.защиты: {e}")
            return False, "❌ Ошибка анализа соц.настроений"

class DynamicPositionManager:
    """Динамическое управление позициями вместо статических TP/SL"""
    
    def __init__(self, trader):
        self.trader = trader
        self.active_managements = {}
        logger.info("Dynamic Position Manager инициализирован")
    
    def manage_position(self, symbol: str, position: Dict, technical_data: Dict):
        """Активное управление открытой позицией"""
        
        try:
            current_price = self.trader.get_ticker(symbol)
            if current_price <= 0:
                return
            
            entry_price = position['entry_price']
            position_side = position['side']
            current_pnl = self.calculate_pnl(position, current_price)
            
            risk_data = technical_data['risk']
            atr = risk_data['atr']
            
            if symbol not in self.active_managements:
                self.active_managements[symbol] = {
                    'entry_price': entry_price,
                    'side': position_side,
                    'highest_pnl': 0,
                    'lowest_pnl': 0,
                    'last_management_time': datetime.now(),
                    'partial_closes': 0
                }
            
            management = self.active_managements[symbol]
            
            if current_pnl > management['highest_pnl']:
                management['highest_pnl'] = current_pnl
            if current_pnl < management['lowest_pnl']:
                management['lowest_pnl'] = current_pnl
            
            dynamic_sl = self.calculate_dynamic_sl(entry_price, atr, position_side)
            
            if current_pnl > 0.02:
                new_sl = self.calculate_trailing_stop(entry_price, current_price, atr, position_side, management['highest_pnl'])
                if self.should_update_sl(position_side, new_sl, current_price):
                    self.update_stop_loss(symbol, new_sl)
                    logger.info(f"🔧 Обновлен SL для {symbol}: {new_sl:.4f}")
            
            if current_pnl >= 0.05 and management['partial_closes'] == 0:
                self.close_partial_position(symbol, 0.3)
                management['partial_closes'] += 1
                logger.info(f"🎯 Частичное закрытие {symbol}: 30% @ +5%")
            
            elif current_pnl >= 0.08 and management['partial_closes'] == 1:
                self.close_partial_position(symbol, 0.5)
                management['partial_closes'] += 1
                logger.info(f"🎯 Частичное закрытие {symbol}: 50% @ +8%")
            
            management['last_management_time'] = datetime.now()
            
        except Exception as e:
            logger.error(f"Ошибка управления позицией {symbol}: {e}")
    
    def calculate_dynamic_sl(self, entry_price: float, atr: float, side: str) -> float:
        if atr == 0:
            return entry_price * 0.98 if side == 'long' else entry_price * 1.02
        
        if side == 'long':
            return entry_price - (atr * 1.5)
        else:
            return entry_price + (atr * 1.5)
    
    def calculate_trailing_stop(self, entry_price: float, current_price: float, atr: float, side: str, highest_pnl: float) -> float:
        if side == 'long':
            if highest_pnl > 0.02:
                return max(entry_price * 1.005, current_price - (atr * 1.0))
            else:
                return current_price - (atr * 1.5)
        else:
            if highest_pnl > 0.02:
                return min(entry_price * 0.995, current_price + (atr * 1.0))
            else:
                return current_price + (atr * 1.5)
    
    def should_update_sl(self, side: str, new_sl: float, current_price: float) -> bool:
        if side == 'long':
            return new_sl > current_price * 0.995
        else:
            return new_sl < current_price * 1.005
    
    def calculate_pnl(self, position: Dict, current_price: float) -> float:
        entry_price = position['entry_price']
        if position['side'] == 'long':
            return (current_price - entry_price) / entry_price
        else:
            return (entry_price - current_price) / entry_price
    
    def update_stop_loss(self, symbol: str, stop_loss: float):
        try:
            logger.info(f"🔄 SL обновлен для {symbol}: {stop_loss:.4f}")
        except Exception as e:
            logger.error(f"Ошибка обновления SL: {e}")
    
    def close_partial_position(self, symbol: str, percentage: float):
        try:
            logger.info(f"📉 Частичное закрытие {symbol}: {percentage*100}%")
        except Exception as e:
            logger.error(f"Ошибка частичного закрытия: {e}")

class SmartTradingPipeline:
    """Улучшенный умный торговый пайплайн с оптимизированными параметрами"""
    
    def __init__(self, trader, technical_analyzer, grok_filter, social_guard, position_manager):
        self.trader = trader
        self.technical_analyzer = technical_analyzer
        self.grok_filter = grok_filter
        self.social_guard = social_guard
        self.position_manager = position_manager
        
        self.daily_trade_count = 0
        self.last_trade_day = datetime.now().date()
        self.max_daily_trades = 5
        self.executed_trades = []
        self.symbol_trade_count = {}
        self.initial_grok_analysis = {}
        
        logger.info("🎯 Smart Trading Pipeline инициализирован")
    
    def set_initial_grok_analysis(self, initial_analysis: Dict):
        """Установка первоначальных анализов Grok"""
        self.initial_grok_analysis = initial_analysis
        logger.info(f"🎯 Загружено {len(initial_analysis)} первоначальных анализов Grok")
    
    def process_trade_decision(self, symbol: str) -> Dict:
        """Улучшенный пайплайн принятия торговых решений с детальной диагностикой"""
        
        try:
            if not self.can_trade_today(symbol):
                return {'action': 'HOLD', 'reason': 'Дневной лимит сделок исчерпан', 'confidence': 0}
            
            technical_data = self.technical_analyzer.get_multi_timeframe_analysis(symbol, self.trader.exchange)
            
            # 🔍 ДИАГНОСТИКА - ДОБАВЛЕНО
            # Используем первоначальный анализ Grok если доступен
            if symbol in self.initial_grok_analysis:
                primary_trend = self.initial_grok_analysis[symbol]
                logger.info(f"🎯 {symbol} - Используем начальный Grok: {primary_trend.get('trend')} ({primary_trend.get('confidence', 0):.2f})")
            else:
                primary_trend = self.grok_filter.analyze_primary_trend(symbol, technical_data)
                logger.info(f"🎯 {symbol} - Новый Grok анализ: {primary_trend.get('trend')} ({primary_trend.get('confidence', 0):.2f})")
            
            entry_signal = technical_data['entry']
            logger.info(f"🔧 {symbol} - Тех.сигнал: {entry_signal['action']} (conf: {entry_signal['confidence']:.2f})")
            
            # Проверка согласованности
            should_enter = self.grok_filter.should_enter_trade(
                primary_trend['trend'], 
                entry_signal['action'],
                primary_trend['confidence']
            )
            logger.info(f"🤝 {symbol} - Согласованность: {should_enter}")
            
            if not should_enter:
                logger.info(f"🚫 {symbol} - ПРИЧИНА HOLD: Несогласованность тренда {primary_trend['trend']} vs сигнала {entry_signal['action']}")
                return {
                    'action': 'HOLD', 
                    'reason': f"Несогласованность: тренд {primary_trend['trend']} vs сигнал {entry_signal['action']}",
                    'confidence': entry_signal['confidence']  # 🔍 ДОБАВЛЕНО confidence для дашборда
                }
            
            analysis_for_social = {
                'action': entry_signal['action'],
                'primary_trend': primary_trend,
                'confidence': entry_signal['confidence']
            }
            
            should_avoid, social_reason = self.social_guard.should_avoid_trade(symbol, analysis_for_social)
            if should_avoid:
                return {'action': 'HOLD', 'reason': social_reason, 'confidence': entry_signal['confidence']}
            
            execution_data = technical_data['execution']
            if execution_data['optimal_entry'] is None or execution_data['confidence'] < 0.4:
                return {'action': 'HOLD', 'reason': 'Слабые условия для точного входа', 'confidence': entry_signal['confidence']}
            
            if not self.passes_quality_checks(symbol, technical_data, primary_trend, entry_signal):
                return {'action': 'HOLD', 'reason': 'Не пройдены проверки качества', 'confidence': entry_signal['confidence']}
            
            trade_result = self.execute_trade(symbol, technical_data, primary_trend, entry_signal)
            
            if trade_result['executed']:
                self.record_trade_execution(symbol)
                return {'action': 'EXECUTED', 'trade': trade_result, 'confidence': entry_signal['confidence']}
            else:
                # 🔍 ДЕТАЛЬНАЯ ДИАГНОСТИКА ОШИБКИ ИСПОЛНЕНИЯ - ДОБАВЛЕНО
                logger.error(f"❌ {symbol} - Ошибка исполнения: {trade_result.get('reason', 'Unknown error')}")
                return {'action': 'HOLD', 'reason': f"Ошибка исполнения: {trade_result.get('reason', 'Unknown error')}", 'confidence': entry_signal['confidence']}
            
        except Exception as e:
            logger.error(f"Ошибка торгового пайплайна {symbol}: {e}")
            return {'action': 'HOLD', 'reason': f'Ошибка пайплайна: {str(e)}', 'confidence': 0}
    
    def can_trade_today(self, symbol: str) -> bool:
        today = datetime.now().date()
        if today != self.last_trade_day:
            self.daily_trade_count = 0
            self.symbol_trade_count = {}
            self.last_trade_day = today
        
        symbol_count = self.symbol_trade_count.get(symbol, 0)
        can_trade = self.daily_trade_count < self.max_daily_trades and symbol_count < 2
        
        if not can_trade:
            logger.warning(f"🚫 Достигнут лимит сделок: общие {self.daily_trade_count}/{self.max_daily_trades}, {symbol}: {symbol_count}/2")
        
        return can_trade
    
    def passes_quality_checks(self, symbol: str, technical_data: Dict, primary_trend: Dict, entry_signal: Dict) -> bool:
        # 🔍 ДЕТАЛЬНАЯ ДИАГНОСТИКА ПРОВЕРОК КАЧЕСТВА - ДОБАВЛЕНО
        checks = []
        
        # 1. Confidence check
        conf_check = entry_signal['confidence'] >= 0.4
        checks.append(f"Confidence: {entry_signal['confidence']:.2f} >= 0.4 = {conf_check}")
        
        # 2. Trend confidence
        trend_check = primary_trend['confidence'] >= 0.4
        checks.append(f"Trend confidence: {primary_trend['confidence']:.2f} >= 0.4 = {trend_check}")
        
        # 3. Volatility check
        vol_check = technical_data['risk']['volatility'] != 'HIGH' or entry_signal['confidence'] > 0.6
        checks.append(f"Volatility: {technical_data['risk']['volatility']} check = {vol_check}")
        
        # 4. RSI check
        rsi = entry_signal.get('rsi', 50)
        rsi_check = 15 <= rsi <= 85
        checks.append(f"RSI: {rsi:.1f} in [15,85] = {rsi_check}")
        
        # 5. Execution confidence
        exec_check = technical_data['execution']['confidence'] >= 0.3
        checks.append(f"Execution: {technical_data['execution']['confidence']:.2f} >= 0.3 = {exec_check}")
        
        # 6. ADX check
        adx = technical_data['trend'].get('adx', 0)
        adx_check = adx > 10 or entry_signal['confidence'] > 0.6
        checks.append(f"ADX: {adx:.1f} > 10 = {adx_check}")
        
        score = sum([conf_check, trend_check, vol_check, rsi_check, exec_check, adx_check])
        passes = score >= 4
        
        logger.info(f"📋 {symbol} - Quality checks: {score}/6")
        for check in checks:
            logger.info(f"   📝 {check}")
        logger.info(f"   ✅ Final quality: {passes}")
        
        return passes
    
    def execute_trade(self, symbol: str, technical_data: Dict, primary_trend: Dict, entry_signal: Dict) -> Dict:
        try:
            execution_data = technical_data['execution']
            risk_data = technical_data['risk']
            
            position_size_percent = self.calculate_position_size(
                entry_signal['confidence'], 
                risk_data['volatility'],
                risk_data.get('position_size_multiplier', 1.0)
            )
            
            current_price = execution_data['current_price']
            atr = risk_data['atr']
            
            if entry_signal['action'] == 'BUY':
                stop_loss = current_price - (atr * risk_data['recommended_sl_multiplier'])
                take_profit = current_price + (atr * 2.5)
                side = 'buy'
            else:
                stop_loss = current_price + (atr * risk_data['recommended_sl_multiplier'])
                take_profit = current_price - (atr * 2.5)
                side = 'sell'
            
            account_info = self.trader.get_account_info()
            position_size_usdt = account_info['available_balance'] * position_size_percent / 100
            
            # 🔍 ДИАГНОСТИКА РАСЧЕТА РАЗМЕРА ПОЗИЦИИ - ДОБАВЛЕНО
            logger.info(f"💰 {symbol} - Расчет позиции:")
            logger.info(f"   Баланс: {account_info['available_balance']:.2f} USDT")
            logger.info(f"   Размер: {position_size_percent:.1f}% = {position_size_usdt:.2f} USDT")
            logger.info(f"   Цена: {current_price:.4f}")
            logger.info(f"   Количество: {position_size_usdt / current_price:.4f}")
            
            if position_size_usdt < 10:
                logger.warning(f"💰 {symbol} - Слишком маленький размер позиции: {position_size_usdt:.2f} USDT")
                return {'executed': False, 'reason': 'Слишком маленький размер позиции'}
            
            position_size = position_size_usdt / current_price
            
            # 🔍 ДИАГНОСТИКА ПАРАМЕТРОВ ОРДЕРА - ДОБАВЛЕНО
            logger.info(f"📊 {symbol} - Параметры ордера:")
            logger.info(f"   Сторона: {side}")
            logger.info(f"   Размер: {position_size:.4f}")
            logger.info(f"   Цена: {current_price:.4f}")
            logger.info(f"   SL: {stop_loss:.4f}")
            logger.info(f"   TP: {take_profit:.4f}")
            
            order = self.trader.create_order(
                symbol, 'market', side, position_size,
                take_profit=take_profit,
                stop_loss=stop_loss
            )
            
            if order:
                trade_info = {
                    'symbol': symbol,
                    'side': side,
                    'size': position_size,
                    'entry_price': current_price,
                    'stop_loss': stop_loss,
                    'take_profit': take_profit,
                    'timestamp': datetime.now().isoformat(),
                    'confidence': entry_signal['confidence'],
                    'trend': primary_trend['trend'],
                    'position_size_percent': position_size_percent,
                    'position_size_usdt': position_size_usdt
                }
                
                self.executed_trades.append(trade_info)
                logger.info(f"✅ СДЕЛКА ИСПОЛНЕНА: {side} {symbol} @ {current_price:.4f}, размер: {position_size_percent:.1f}%")
                
                return {
                    'executed': True,
                    'trade': trade_info,
                    'position_size_usdt': position_size_usdt
                }
            else:
                logger.error(f"❌ {symbol} - Ошибка создания ордера")
                return {'executed': False, 'reason': 'Ошибка создания ордера'}
            
        except Exception as e:
            logger.error(f"❌ {symbol} - Ошибка исполнения сделки: {e}")
            return {'executed': False, 'reason': f'Ошибка исполнения: {str(e)}'}
    
    def calculate_position_size(self, confidence: float, volatility: str, adx_multiplier: float) -> float:
        base_size = 15
        
        confidence_multiplier = min(confidence / 0.7, 1.2)
        
        if volatility == 'HIGH':
            volatility_multiplier = 0.7
        elif volatility == 'MEDIUM':
            volatility_multiplier = 0.9
        else:
            volatility_multiplier = 1.1
        
        final_size = base_size * confidence_multiplier * volatility_multiplier * adx_multiplier
        return min(final_size, 20)
    
    def record_trade_execution(self, symbol: str):
        self.daily_trade_count += 1
        self.symbol_trade_count[symbol] = self.symbol_trade_count.get(symbol, 0) + 1
        logger.info(f"📊 Сделка записана. Сегодня: {self.daily_trade_count}/{self.max_daily_trades}, {symbol}: {self.symbol_trade_count[symbol]}/2")
    
    def get_pipeline_stats(self) -> Dict:
        return {
            'daily_trades': f"{self.daily_trade_count}/{self.max_daily_trades}",
            'total_executed_trades': len(self.executed_trades),
            'symbol_trades': self.symbol_trade_count,
            'last_trade_day': self.last_trade_day.isoformat(),
            'initial_grok_analysis_count': len(self.initial_grok_analysis)
        }

class KnowledgeBase:
    def __init__(self, file_path: str = 'knowledge_base.json'):
        self.file_path = file_path
        self.analysis_history = []
        self.lock = threading.Lock()
        self._last_save = datetime.now()
        self.load_from_file()
    
    def record_analysis(self, symbol: str, analysis: Dict, account_info: Dict):
        """🔧 ОПТИМИЗИРОВАННАЯ ЗАПИСЬ С ОГРАНИЧЕНИЕМ РАЗМЕРА"""
        with self.lock:
            entry = {
                'timestamp': datetime.now().isoformat(),
                'symbol': symbol,
                'analysis': analysis,
                'account_info': account_info
            }
            
            # Ограничиваем размер истории
            if len(self.analysis_history) >= 1000:
                self.analysis_history = self.analysis_history[-500:]
                logger.info("🧹 Сокращена история анализа до 500 записей")
            
            self.analysis_history.append(entry)
            
            # Сохраняем на диск только каждые 10 минут
            if (datetime.now() - self._last_save) > timedelta(minutes=10):
                self.save_to_file()
                self._last_save = datetime.now()

    def save_to_file(self):
        """🔧 ОПТИМИЗИРОВАННОЕ СОХРАНЕНИЕ"""
        try:
            # Сохраняем только последние 200 записей
            data = {
                'analysis_history': self.analysis_history[-200:],
                'last_updated': datetime.now().isoformat()
            }
            
            with open(self.file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"Ошибка сохранения Knowledge Base: {e}")

    def load_from_file(self):
        try:
            if not os.path.exists(self.file_path):
                return
            with open(self.file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.analysis_history = data.get('analysis_history', [])
        except Exception as e:
            logger.error(f"Ошибка загрузки Knowledge Base: {e}")
            self.analysis_history = []
    
    def get_recent_analysis(self, limit: int = 10):
        return self.analysis_history[-limit:]

class TradingScheduler:
    def __init__(self, trading_pipeline, trader, knowledge_base):
        self.trading_pipeline = trading_pipeline
        self.trader = trader
        self.knowledge = knowledge_base
        self.symbols = []
        self.is_running = False
        self.analysis_count = 0
        self.analysis_interval = 30
        self._last_memory_check = datetime.now()
        logger.info("Trading Scheduler инициализирован")
    
    def _check_memory_usage(self):
        """Проверка и оптимизация использования памяти"""
        if (datetime.now() - self._last_memory_check) > timedelta(hours=2):
            logger.info("🔍 Проверка использования памяти...")
            
            # Принудительный сбор мусора
            collected = gc.collect()
            logger.info(f"🧹 Сборщик мусора освободил {collected} объектов")
            
            self._last_memory_check = datetime.now()

    def setup(self, symbols: list, leverage: int, max_position_size: int):
        working_symbols = []
        for symbol in symbols:
            try:
                price = self.trader.get_ticker(symbol)
                if price > 0:
                    working_symbols.append(symbol)
                    self.trader.set_leverage(symbol, leverage)
                    logger.info(f"Символ {symbol} работает, цена: {price}")
            except Exception as e:
                logger.warning(f"Символ {symbol} не работает: {e}")
        
        self.symbols = working_symbols
        logger.info(f"Настроено {len(self.symbols)} рабочих символов")
    
    def run_market_analysis(self):
        try:
            self._check_memory_usage()
            self.analysis_count += 1
            
            # 🔧 ОГРАНИЧИВАЕМ СЧЕТЧИК АНАЛИЗА ДЛЯ ПРЕДОТВРАЩЕНИЯ ПЕРЕПОЛНЕНИЯ
            if self.analysis_count > 1000000:
                self.analysis_count = 1
                logger.info("🔄 Сброс счетчика анализа")
            
            logger.info(f"🔍 ЗАПУСК АНАЛИЗА #{self.analysis_count} - {datetime.now().strftime('%H:%M:%S')}")
            
            account_info = self.trader.get_account_info()
            logger.info(f"Баланс: {account_info['total_balance']:.2f} USDT, Доступно: {account_info['available_balance']:.2f} USDT")
            
            pipeline_stats = self.trading_pipeline.get_pipeline_stats()
            logger.info(f"📊 Статистика пайплайна: {pipeline_stats['daily_trades']}")
            
            for symbol in self.symbols:
                try:
                    logger.info(f"Анализируем {symbol}...")
                    
                    decision = self.trading_pipeline.process_trade_decision(symbol)
                    logger.info(f"Результат для {symbol}: {decision.get('action')}")
                    
                    self.knowledge.record_analysis(symbol, decision, account_info)
                    
                    time.sleep(2)  # Задержка между символами
                    
                except Exception as e:
                    logger.error(f"Ошибка анализа {symbol}: {e}")
                    continue  # 🔧 ПРОДОЛЖАЕМ РАБОТУ ПРИ ОШИБКАХ ОТДЕЛЬНЫХ СИМВОЛОВ
            
            logger.info(f"✅ АНАЛИЗ #{self.analysis_count} ЗАВЕРШЕН")
                    
        except Exception as e:
            logger.error(f"Критическая ошибка анализа рынка: {e}")
            # 🔧 НЕ ПАДАЕМ ПОЛНОСТЬЮ ПРИ ОШИБКАХ

    def start(self):
        self.is_running = True
        logger.info(f"🔄 Планировщик запущен - анализ каждые {self.analysis_interval} минут")
        
        while self.is_running:
            try:
                self.run_market_analysis()
                logger.info(f"⏰ Ожидание {self.analysis_interval} минут до следующего анализа...")
                
                # 🔧 ОПТИМИЗИРОВАННОЕ ОЖИДАНИЕ С ПРОВЕРКОЙ ОСТАНОВКИ
                wait_seconds = self.analysis_interval * 60
                for i in range(wait_seconds):
                    if not self.is_running:
                        break
                    if i % 60 == 0:  # Логируем каждую минуту
                        minutes_left = (wait_seconds - i) // 60
                        logger.debug(f"⏳ До следующего анализа: {minutes_left} мин")
                    time.sleep(1)
                    
            except Exception as e:
                logger.error(f"Ошибка в основном цикле: {e}")
                time.sleep(60)  # 🔧 КОРОТКАЯ ПАУЗА ПРИ ОШИБКАХ

    def stop(self):
        self.is_running = False
        logger.info("🛑 Планировщик остановлен")

# 🔧 ОБНОВЛЕННАЯ ФУНКЦИЯ ИНИЦИАЛИЗАЦИИ СЕАНСА
def init_session_state():
    """Инициализация состояния сеанса с защитой от рекурсии"""
    required_keys = {
        'bot_started': False,
        'trader': None,
        'scheduler': None,
        'grok_status': "Не проверен",
        'last_update': None,
        'scheduler_running': False,
        'initial_grok_analysis': {},
        'session_start_time': datetime.now().isoformat(),
        'refresh_count': 0
    }
    
    for key, default_value in required_keys.items():
        if key not in st.session_state:
            st.session_state[key] = default_value

# 🔧 ОБНОВЛЕННАЯ ГЛАВНАЯ ФУНКЦИЯ С ЗАЩИТОЙ ОТ РЕКУРСИИ
def main():
    st.set_page_config(
        page_title="Grok Smart Trading Bot v2.4", 
        layout="wide", 
        page_icon="🤖",
        initial_sidebar_state="expanded"
    )
    
    init_session_state()
    
    # 🔧 СЧЕТЧИК ОБНОВЛЕНИЙ ДЛЯ ПРЕДОТВРАЩЕНИЯ РЕКУРСИИ
    st.session_state.refresh_count += 1
    if st.session_state.refresh_count > 1000:
        st.session_state.refresh_count = 1
        logger.info("🔄 Сброс счетчика обновлений интерфейса")
    
    st.title("🤖 Grok Smart Trading Bot v2.4")
    st.markdown("### Стабильная версия с исправлением рекурсии")
    
    # 🔧 ОПТИМИЗИРОВАННЫЙ САЙДБАР
    with st.sidebar:
        st.header("🔧 Настройки Торговли")
        
        st.subheader("⚙️ Параметры Торговли")
        
        top_symbols = [
            'BTC/USDT:USDT', 'ETH/USDT:USDT', 'SOL/USDT:USDT', 'BNB/USDT:USDT',
            'XRP/USDT:USDT', 'ADA/USDT:USDT', 'AVAX/USDT:USDT', 'DOGE/USDT:USDT',
            'DOT/USDT:USDT', 'LINK/USDT:USDT'
        ]
        
        selected_symbols = st.multiselect(
            "Торгуемые фьючерсы (макс 8):", 
            top_symbols, 
            default=['BTC/USDT:USDT', 'ETH/USDT:USDT', 'SOL/USDT:USDT', 'BNB/USDT:USDT'],
            max_selections=8
        )
        
        leverage = st.slider("Плечо:", 1, 10, 5)
        position_size = st.slider("Размер позиции (%):", 5, 30, 15)
        
        st.subheader("🗃️ Управление данными")
        if st.button("🧹 Очистить Knowledge Base", type="secondary"):
            if os.path.exists('knowledge_base.json'):
                os.remove('knowledge_base.json')
                st.success("✅ Knowledge Base очищена!")
            else:
                st.info("📁 Knowledge Base не найдена")
        
        st.subheader("🚀 Управление")
        col1, col2 = st.columns(2)
        
        with col1:
            if st.button("🚀 Запустить бота", type="primary", use_container_width=True):
                if not selected_symbols:
                    st.error("❌ Выберите символы для торговли!")
                else:
                    start_trading_bot(selected_symbols, leverage, position_size)
        
        with col2:
            if st.button("🛑 Остановить бота", use_container_width=True):
                stop_trading_bot()
        
        # 🔧 ИНФОРМАЦИЯ О СЕАНСЕ
        st.divider()
        if st.session_state.bot_started:
            session_time = datetime.now() - datetime.fromisoformat(st.session_state.session_start_time)
            st.info(f"**Сеанс:** {str(session_time).split('.')[0]}")
            st.info(f"**Обновлений:** {st.session_state.refresh_count}")

    if st.session_state.bot_started:
        display_trading_dashboard()
    else:
        display_welcome_screen()
    
    # 🔧 ОПТИМИЗИРОВАННОЕ ОБНОВЛЕНИЕ ИНТЕРФЕЙСА
    if st.session_state.bot_started and st.session_state.scheduler_running:
        # Обновляем каждые 15 секунд вместо 10
        time.sleep(15)
        st.rerun()

def display_welcome_screen():
    st.info("👆 Настройте параметры и запустите бота для начала торговли")
    
    with st.expander("🔍 Стабильная версия v2.4", expanded=True):
        st.markdown("""
        ### 🎯 КЛЮЧЕВЫЕ ИСПРАВЛЕНИЯ:
        **🔧 Исправление рекурсии:**
        - Увеличен лимит рекурсии до 2000
        - Оптимизированы вызовы Streamlit
        - Регулярная очистка кэшей
        **🧹 Управление памятью:**
        - Автоочистка старых данных
        - Ограничение размера истории
        - Принудительный сбор мусора
        **⚡ Оптимизация производительности:**
        - Увеличен интервал обновления до 15 секунд
        - Упрощенный дашборд
        - Ограниченное количество символов
        **🎯 Стабильная работа:**
        - Защита от ошибок отдельных символов
        - Продолжение работы при частичных сбоях
        - Глобальная обработка исключений
        """)

def start_trading_bot(symbols, leverage, position_size):
    try:
        if st.session_state.scheduler_running:
            st.warning("Бот уже запущен!")
            return True
        
        st.info("🔄 Инициализация СТАБИЛЬНОГО торгового бота v2.4...")
        
        # Прогресс-бар для визуализации запуска
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        status_text.text("Шаг 1/4: Инициализация компонентов...")
        progress_bar.progress(25)
        
        # Используем вшитые ключи
        bybit_api_key = "OqFgjGKhzUyTU2Yesq"
        bybit_secret = "UazxgpqNbiFCFApiOHAd1f1s57a2GhXc4w7x"
        grok_api_key = "xai-p4j0VXesw69krSosEru3vufOu8XQkpYpMU7MBxQi9BGMFn6jq5QmAhjwsmcRD2CcEtfhvG28os6Ld822"
        
        # Инициализация компонентов
        trader = BybitFuturesTrader(bybit_api_key, bybit_secret, False)
        technical_analyzer = AdvancedTechnicalAnalyzer()
        grok_filter = GrokTrendFilter(grok_api_key)
        social_guard = SocialSentimentGuard()
        position_manager = DynamicPositionManager(trader)
        
        status_text.text("Шаг 2/4: Настройка символов и плеча...")
        progress_bar.progress(50)
        
        # Создание улучшенного пайплайна
        trading_pipeline = SmartTradingPipeline(
            trader, technical_analyzer, grok_filter, social_guard, position_manager
        )
        
        knowledge = KnowledgeBase()
        knowledge.load_from_file()
        
        status_text.text("Шаг 3/4: Запуск мгновенного анализа Grok...")
        progress_bar.progress(75)
        
        # ВЫПОЛНЯЕМ МГНОВЕННЫЙ АНАЛИЗ GROK ПРИ ЗАПУСКЕ
        initial_grok_analysis = grok_filter.perform_initial_analysis(symbols, technical_analyzer, trader.exchange)
        
        # Сохраняем результаты первоначального анализа
        trading_pipeline.set_initial_grok_analysis(initial_grok_analysis)
        st.session_state.initial_grok_analysis = initial_grok_analysis
        
        status_text.text("Шаг 4/4: Запуск планировщика...")
        progress_bar.progress(100)
        
        scheduler = TradingScheduler(trading_pipeline, trader, knowledge)
        scheduler.setup(symbols, leverage, position_size)
        
        if not scheduler.symbols:
            st.error("❌ Нет рабочих символов!")
            return False
        
        st.session_state.trader = trader
        st.session_state.scheduler = scheduler
        st.session_state.trading_pipeline = trading_pipeline
        st.session_state.grok_filter = grok_filter
        
        def run_scheduler():
            scheduler.start()
        
        scheduler_thread = threading.Thread(target=run_scheduler)
        scheduler_thread.daemon = True
        scheduler_thread.start()
        
        st.session_state.bot_started = True
        st.session_state.scheduler_running = True
        
        # Очищаем прогресс-бар
        progress_bar.empty()
        status_text.empty()
        
        st.success("✅ СТАБИЛЬНЫЙ бот v2.4 запущен!")
        
        # Показываем результаты первоначального анализа
        if initial_grok_analysis:
            st.subheader("🎯 Результаты мгновенного анализа Grok:")
            for symbol, analysis in initial_grok_analysis.items():
                trend = analysis.get('trend', 'NEUTRAL')
                confidence = analysis.get('confidence', 0) * 100
                reasoning = analysis.get('reasoning', '')[:100] + "..." if len(analysis.get('reasoning', '')) > 100 else analysis.get('reasoning', '')
                
                if trend == 'BULLISH':
                    st.success(f"**{symbol}**: 🟢 {trend} ({confidence:.1f}%) - {reasoning}")
                elif trend == 'BEARISH':
                    st.error(f"**{symbol}**: 🔴 {trend} ({confidence:.1f}%) - {reasoning}")
                else:
                    st.info(f"**{symbol}**: ⚪ {trend} ({confidence:.1f}%) - {reasoning}")
        
        return True
        
    except Exception as e:
        st.error(f"❌ Ошибка запуска: {str(e)}")
        return False

def stop_trading_bot():
    if st.session_state.scheduler:
        st.session_state.scheduler.stop()
        st.session_state.trader = None
        st.session_state.scheduler = None
        st.session_state.scheduler_running = False
        st.session_state.initial_grok_analysis = {}
        st.success("🛑 Бот остановлен")
        st.session_state.bot_started = False
    else:
        st.warning("⚠️ Бот не запущен")

# 🔧 ОБНОВЛЕННАЯ ФУНКЦИЯ ДАШБОРДА
def display_trading_dashboard():
    """Оптимизированный дашборд с защитой от ошибок"""
    
    st.header("📊 Дашборд Стабильного Торгового Бота v2.4")
    
    try:
        st.session_state.last_update = datetime.now().strftime("%H:%M:%S")
        
        if st.session_state.trader:
            # 🔧 ЗАЩИЩЕННЫЙ ПОЛУЧЕНИЕ ИНФОРМАЦИИ О СЧЕТЕ
            try:
                account_info = st.session_state.trader.get_account_info()
            except Exception as e:
                logger.error(f"Ошибка получения информации о счете: {e}")
                account_info = {
                    'total_balance': 0.0, 'available_balance': 0.0, 'margin_used': 0.0,
                    'positions_count': 0, 'orders_count': 0, 'unrealized_pnl': 0.0
                }
            
            col1, col2, col3, col4, col5 = st.columns(5)
            with col1:
                st.metric("Общий баланс", f"{account_info['total_balance']:.2f} USDT")
            with col2:
                st.metric("Доступно", f"{account_info['available_balance']:.2f} USDT")
            with col3:
                st.metric("P&L", f"{account_info['unrealized_pnl']:.2f} USDT")
            with col4:
                st.metric("Позиции", account_info['positions_count'])
            with col5:
                st.metric("Ордера", account_info['orders_count'])
            
            # 🔧 ЗАЩИЩЕННОЕ ОТОБРАЖЕНИЕ СТАТИСТИКИ
            if st.session_state.trading_pipeline:
                try:
                    pipeline_stats = st.session_state.trading_pipeline.get_pipeline_stats()
                    
                    col1, col2, col3, col4 = st.columns(4)
                    with col1:
                        st.metric("Сделок сегодня", pipeline_stats['daily_trades'])
                    with col2:
                        st.metric("Всего сделок", pipeline_stats['total_executed_trades'])
                    with col3:
                        st.metric("Архитектура", "v2.4 СТАБИЛЬНАЯ")
                    with col4:
                        st.metric("Следующий анализ", "30 мин")
                except Exception as e:
                    st.error(f"Ошибка статистики: {e}")
            
            # 🔧 УПРОЩЕННАЯ ИСТОРИЯ РЕШЕНИЙ
            if st.session_state.scheduler:
                try:
                    st.subheader("📝 Последние решения")
                    recent = st.session_state.scheduler.knowledge.get_recent_analysis(limit=5)
                    if recent:
                        simplified_data = []
                        for r in recent:
                            simplified_data.append({
                                'Время': r['timestamp'][11:16],
                                'Символ': r['symbol'],
                                'Решение': r['analysis'].get('action', 'N/A'),
                                'Причина': (r['analysis'].get('reason', 'N/A')[:40] + '...') if len(r['analysis'].get('reason', '')) > 40 else r['analysis'].get('reason', 'N/A')
                            })
                        st.dataframe(pd.DataFrame(simplified_data), use_container_width=True)
                    else:
                        st.info("История пуста")
                except Exception as e:
                    st.warning("Не удалось загрузить историю решений")
            
            st.info(f"🕒 Обновлено: {st.session_state.last_update} | 🔄 {st.session_state.refresh_count}")
            
    except Exception as e:
        logger.error(f"Критическая ошибка дашборда: {e}")
        st.error("⚠️ Временная ошибка отображения. Бот продолжает работать.")

if __name__ == "__main__":
    try:
        main()
    except RecursionError as e:
        logger.critical(f"КРИТИЧЕСКАЯ ОШИБКА РЕКУРСИИ: {e}")
        st.error("""
        🚨 Критическая ошибка рекурсии! 
        Пожалуйста, перезапустите приложение.
        """)
    except Exception as e:
        logger.critical(f"КРИТИЧЕСКАЯ ОШИБКА: {e}")
        st.error("""
        🚨 Критическая ошибка! 
        Пожалуйста, перезапустите приложение.
        """)
